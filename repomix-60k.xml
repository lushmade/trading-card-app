This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: PLAN.md, worklog.md, templates_plan.md, PROBLEM.md, instructions.md, LICENSE, *.svg, .repomix-config.json, turbo.json, README.md, **/README.md, .github/**, **/eslint.config.js, **/*.d.ts, **/tsconfig*.json, .gitignore, **/.gitignore, shared/src/tournaments/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.husky/
  _/
    applypatch-msg
    commit-msg
    h
    husky.sh
    post-applypatch
    post-checkout
    post-commit
    post-merge
    post-rewrite
    pre-applypatch
    pre-auto-gc
    pre-commit
    pre-merge-commit
    pre-push
    pre-rebase
    prepare-commit-msg
  pre-commit
client/
  public/
    vite.svg
  src/
    components/
      CropGuides.tsx
      TemplateEditor.tsx
      TemplatePreview.tsx
    Admin.tsx
    api.ts
    App.tsx
    draftStorage.ts
    index.css
    main.tsx
    renderCard.ts
    router.tsx
  index.html
  package.json
  vite.config.ts
server/
  src/
    dev.ts
    index.ts
    lambda.ts
  package.json
shared/
  src/
    types/
      index.ts
    constants.ts
    index.ts
    templates.ts
    validation.ts
  package.json
CLAUDE.md
package.json
pnpm-workspace.yaml
sst.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".husky/_/applypatch-msg">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/commit-msg">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/h">
#!/usr/bin/env sh
[ "$HUSKY" = "2" ] && set -x
n=$(basename "$0")
s=$(dirname "$(dirname "$0")")/$n

[ ! -f "$s" ] && exit 0

if [ -f "$HOME/.huskyrc" ]; then
	echo "husky - '~/.huskyrc' is DEPRECATED, please move your code to ~/.config/husky/init.sh"
fi
i="${XDG_CONFIG_HOME:-$HOME/.config}/husky/init.sh"
[ -f "$i" ] && . "$i"

[ "${HUSKY-}" = "0" ] && exit 0

export PATH="node_modules/.bin:$PATH"
sh -e "$s" "$@"
c=$?

[ $c != 0 ] && echo "husky - $n script failed (code $c)"
[ $c = 127 ] && echo "husky - command not found in PATH=$PATH"
exit $c
</file>

<file path=".husky/_/husky.sh">
echo "husky - DEPRECATED

Please remove the following two lines from $0:

#!/usr/bin/env sh
. \"\$(dirname -- \"\$0\")/_/husky.sh\"

They WILL FAIL in v10.0.0
"
</file>

<file path=".husky/_/post-applypatch">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/post-checkout">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/post-commit">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/post-merge">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/post-rewrite">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/pre-applypatch">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/pre-auto-gc">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/pre-commit">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/pre-merge-commit">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/pre-push">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/pre-rebase">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path=".husky/_/prepare-commit-msg">
#!/usr/bin/env sh
. "$(dirname "$0")/h"
</file>

<file path="client/src/components/CropGuides.tsx">
import { GUIDE_PERCENTAGES } from 'shared'

type CropGuidesProps = {
  visible: boolean
}

const toInsetStyle = (values: typeof GUIDE_PERCENTAGES.trim) => ({
  left: `${values.left}%`,
  top: `${values.top}%`,
  right: `${values.right}%`,
  bottom: `${values.bottom}%`,
})

export default function CropGuides({ visible }: CropGuidesProps) {
  if (!visible) return null

  return (
    <div className="pointer-events-none absolute inset-0 z-10">
      <div
        className="absolute rounded-xl border-2 border-rose-400/80"
        style={toInsetStyle(GUIDE_PERCENTAGES.trim)}
      />
      <div
        className="absolute rounded-lg border-2 border-dashed border-sky-400/80"
        style={toInsetStyle(GUIDE_PERCENTAGES.safe)}
      />
    </div>
  )
}
</file>

<file path="client/src/components/TemplateEditor.tsx">
import { useEffect, useMemo, useState } from 'react'
import type { CardType, TemplateDefinition, TemplateTheme, TournamentConfig } from 'shared'
import TemplatePreview from './TemplatePreview'
import { assetUrlForKey } from '../api'

const SAFE_ID_PATTERN = /^[a-z0-9-]{3,64}$/

const BASE_THEME: TemplateTheme = {
  gradientStart: 'rgba(15, 23, 42, 0)',
  gradientEnd: 'rgba(15, 23, 42, 0.85)',
  border: 'rgba(255, 255, 255, 0.1)',
  accent: 'rgba(255, 255, 255, 0.5)',
  label: '#ffffff',
  nameColor: '#ffffff',
  meta: '#ffffff',
  watermark: 'rgba(255, 255, 255, 0.12)',
}

const THEME_FIELDS: Array<keyof TemplateTheme> = [
  'gradientStart',
  'gradientEnd',
  'border',
  'accent',
  'label',
  'nameColor',
  'meta',
  'watermark',
]

const FLAG_FIELDS = [
  'showGradient',
  'showBorders',
  'showWatermarkJersey',
] as const

type TemplateEditorProps = {
  config: TournamentConfig
  onChange: (next: TournamentConfig) => void
  uploadOverlay: (templateId: string, file: File) => Promise<string>
}

const toHex = (value: string) => {
  const trimmed = value.trim()
  const shortHex = /^#([0-9a-f]{3})$/i.exec(trimmed)
  if (shortHex) {
    const expanded = shortHex[1]
      .split('')
      .map((ch) => `${ch}${ch}`)
      .join('')
    return `#${expanded.toLowerCase()}`
  }
  const fullHex = /^#([0-9a-f]{6})$/i.exec(trimmed)
  if (fullHex) return `#${fullHex[1].toLowerCase()}`

  const rgb = /^rgba?\((\d+),\s*(\d+),\s*(\d+)/i.exec(trimmed)
  if (!rgb) return null
  const [r, g, b] = rgb.slice(1, 4).map((part) => Math.min(255, Math.max(0, Number(part))))
  const toHexPart = (n: number) => n.toString(16).padStart(2, '0')
  return `#${toHexPart(r)}${toHexPart(g)}${toHexPart(b)}`
}

const loadImageDimensions = (file: File): Promise<{ width: number; height: number }> =>
  new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file)
    const img = new Image()
    img.onload = () => {
      URL.revokeObjectURL(url)
      resolve({ width: img.naturalWidth, height: img.naturalHeight })
    }
    img.onerror = () => {
      URL.revokeObjectURL(url)
      reject(new Error('Failed to load image'))
    }
    img.src = url
  })

const normalizeDefaults = (
  templates: TemplateDefinition[],
  defaults: TournamentConfig['defaultTemplates']
) => {
  if (!templates.length) {
    return defaults
  }
  const templateIds = new Set(templates.map((template) => template.id))
  const fallback =
    (defaults?.fallback && templateIds.has(defaults.fallback) && defaults.fallback) ||
    templates[0]?.id ||
    'classic'
  const byCardType = Object.fromEntries(
    Object.entries(defaults?.byCardType ?? {}).filter(([, value]) => value && templateIds.has(value))
  )

  return {
    fallback,
    byCardType,
  }
}

export default function TemplateEditor({ config, onChange, uploadOverlay }: TemplateEditorProps) {
  const templates = useMemo(() => config.templates ?? [], [config.templates])
  const [selectedId, setSelectedId] = useState(templates[0]?.id ?? '')
  const [isCreating, setIsCreating] = useState(false)
  const [newTemplateId, setNewTemplateId] = useState('')
  const [newTemplateLabel, setNewTemplateLabel] = useState('')
  const [formError, setFormError] = useState<string | null>(null)
  const [overlayFile, setOverlayFile] = useState<File | null>(null)
  const [overlayWarning, setOverlayWarning] = useState<string | null>(null)
  const [overlayStatus, setOverlayStatus] = useState<'idle' | 'uploading' | 'error'>('idle')
  const [overlayError, setOverlayError] = useState<string | null>(null)

  const defaults = useMemo(
    () => normalizeDefaults(templates, config.defaultTemplates),
    [config.defaultTemplates, templates]
  )

  useEffect(() => {
    if (!selectedId && templates[0]) {
      setSelectedId(templates[0].id)
      return
    }
    if (selectedId && !templates.some((template) => template.id === selectedId)) {
      setSelectedId(templates[0]?.id ?? '')
    }
  }, [selectedId, templates])

  const selectedTemplate = templates.find((template) => template.id === selectedId) ?? null

  const updateTemplates = (nextTemplates: TemplateDefinition[]) => {
    const nextDefaults = normalizeDefaults(nextTemplates, config.defaultTemplates)
    onChange({
      ...config,
      templates: nextTemplates,
      defaultTemplates: nextDefaults,
    })
  }

  const updateSelectedTemplate = (next: TemplateDefinition) => {
    if (!selectedTemplate) return
    updateTemplates(
      templates.map((template) => (template.id === selectedTemplate.id ? next : template))
    )
  }

  const handleCreateTemplate = () => {
    const id = newTemplateId.trim()
    const label = newTemplateLabel.trim()
    if (!id || !label) {
      setFormError('Template id and label are required')
      return
    }
    if (!SAFE_ID_PATTERN.test(id)) {
      setFormError('Template id must be lowercase letters, numbers, or hyphens')
      return
    }
    if (templates.some((template) => template.id === id)) {
      setFormError('Template id already exists')
      return
    }

    const nextTemplates = [...templates, { id, label }]
    updateTemplates(nextTemplates)
    setSelectedId(id)
    setNewTemplateId('')
    setNewTemplateLabel('')
    setFormError(null)
    setIsCreating(false)
  }

  const handleDeleteTemplate = () => {
    if (!selectedTemplate) return
    if (!window.confirm(`Delete template "${selectedTemplate.label}"?`)) return
    const nextTemplates = templates.filter((template) => template.id !== selectedTemplate.id)

    const nextDefaults = normalizeDefaults(nextTemplates, {
      fallback: defaults?.fallback ?? 'classic',
      byCardType: defaults?.byCardType,
    })

    onChange({
      ...config,
      templates: nextTemplates,
      defaultTemplates: nextDefaults,
    })

    setSelectedId(nextTemplates[0]?.id ?? '')
  }

  const handleOverlayFile = async (file: File | null) => {
    setOverlayFile(file)
    setOverlayWarning(null)
    setOverlayError(null)
    if (!file) return
    try {
      const { width, height } = await loadImageDimensions(file)
      if (width !== 825 || height !== 1125) {
        setOverlayWarning(`Overlay is ${width}×${height}px. Expected 825×1125.`)
      }
    } catch {
      setOverlayWarning('Could not read image dimensions.')
    }
  }

  const handleUploadOverlay = async () => {
    if (!selectedTemplate || !overlayFile) return
    setOverlayStatus('uploading')
    setOverlayError(null)
    try {
      const key = await uploadOverlay(selectedTemplate.id, overlayFile)
      updateSelectedTemplate({
        ...selectedTemplate,
        overlayKey: key,
      })
      setOverlayFile(null)
      setOverlayWarning(null)
      setOverlayStatus('idle')
    } catch (err) {
      setOverlayStatus('error')
      setOverlayError(err instanceof Error ? err.message : 'Upload failed')
    }
  }

  const usedByCardTypes = useMemo(() => {
    const entries = defaults?.byCardType ?? {}
    return new Map<string, CardType[]>(
      Object.entries(entries).reduce((acc, [type, id]) => {
        if (!id) return acc
        const next = acc.get(id) ?? []
        next.push(type as CardType)
        acc.set(id, next)
        return acc
      }, new Map<string, CardType[]>())
    )
  }, [defaults?.byCardType])

  return (
    <section className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
      <div className="flex flex-wrap items-start justify-between gap-4">
        <div>
          <h2 className="text-lg font-semibold text-white">Templates</h2>
          <p className="text-sm text-slate-400">
            Build template styles, assign defaults, and preview renders.
          </p>
        </div>
        <button
          type="button"
          onClick={() => setIsCreating(true)}
          className="rounded-full border border-white/20 px-4 py-2 text-xs text-white hover:border-white/40"
        >
          Add Template
        </button>
      </div>

      <div className="mt-6 grid gap-6 lg:grid-cols-[1.2fr_0.8fr]">
        <div className="space-y-6">
          <div className="grid gap-4 sm:grid-cols-2">
            {templates.map((template) => {
              const isActive = template.id === selectedId
              const usedByFallback = defaults?.fallback === template.id
              const usedBy = usedByCardTypes.get(template.id) ?? []
              return (
                <button
                  key={template.id}
                  type="button"
                  onClick={() => setSelectedId(template.id)}
                  className={`rounded-2xl border p-3 text-left transition ${
                    isActive ? 'border-emerald-500/50 bg-emerald-500/5' : 'border-white/10 bg-slate-950/40'
                  }`}
                >
                  <div className="flex items-start justify-between gap-2">
                    <div>
                      <div className="text-sm text-white">{template.label}</div>
                      <div className="text-[11px] text-slate-500">{template.id}</div>
                    </div>
                    {usedByFallback ? (
                      <span className="rounded-full border border-emerald-500/40 px-2 py-0.5 text-[10px] uppercase tracking-[0.2em] text-emerald-300">
                        Default
                      </span>
                    ) : null}
                  </div>
                  <div className="mt-3 overflow-hidden rounded-xl border border-white/10 bg-slate-950/60">
                    {template.overlayKey ? (
                      <img
                        src={assetUrlForKey(template.overlayKey)}
                        alt={`${template.label} overlay`}
                        className="h-32 w-full object-cover"
                      />
                    ) : (
                      <div className="flex h-32 items-center justify-center text-[11px] text-slate-500">
                        No overlay
                      </div>
                    )}
                  </div>
                  {usedBy.length > 0 ? (
                    <div className="mt-2 text-[11px] text-slate-500">
                      Used for: {usedBy.join(', ')}
                    </div>
                  ) : null}
                </button>
              )
            })}
          </div>

          {isCreating ? (
            <div className="rounded-2xl border border-white/10 bg-slate-950/40 p-4">
              <h3 className="text-sm font-semibold text-white">New Template</h3>
              <div className="mt-3 grid gap-3 sm:grid-cols-2">
                <label className="text-xs uppercase tracking-wide text-slate-400">
                  Template Id
                  <input
                    value={newTemplateId}
                    onChange={(event) => setNewTemplateId(event.target.value)}
                    placeholder="classic-alt"
                    className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  />
                </label>
                <label className="text-xs uppercase tracking-wide text-slate-400">
                  Label
                  <input
                    value={newTemplateLabel}
                    onChange={(event) => setNewTemplateLabel(event.target.value)}
                    placeholder="Classic Alt"
                    className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  />
                </label>
              </div>
              {formError ? (
                <p className="mt-2 text-xs text-rose-300">{formError}</p>
              ) : null}
              <div className="mt-4 flex flex-wrap gap-2">
                <button
                  type="button"
                  onClick={handleCreateTemplate}
                  className="rounded-full bg-white px-4 py-2 text-xs font-semibold text-slate-900"
                >
                  Create
                </button>
                <button
                  type="button"
                  onClick={() => {
                    setIsCreating(false)
                    setFormError(null)
                  }}
                  className="rounded-full border border-white/20 px-4 py-2 text-xs text-slate-300"
                >
                  Cancel
                </button>
              </div>
            </div>
          ) : null}

          {selectedTemplate ? (
            <div className="rounded-2xl border border-white/10 bg-slate-950/40 p-4">
              <div className="flex flex-wrap items-start justify-between gap-3">
                <div>
                  <h3 className="text-sm font-semibold text-white">Template Details</h3>
                  <p className="text-xs text-slate-500">
                    Update overlay, colors, and layout rules.
                  </p>
                </div>
                <button
                  type="button"
                  onClick={handleDeleteTemplate}
                  className="rounded-full border border-rose-500/40 px-3 py-1 text-[11px] text-rose-300"
                >
                  Delete
                </button>
              </div>

              <div className="mt-4 grid gap-3 sm:grid-cols-2">
                <label className="text-xs uppercase tracking-wide text-slate-400">
                  Template Id
                  <input
                    value={selectedTemplate.id}
                    readOnly
                    className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-slate-400"
                  />
                </label>
                <label className="text-xs uppercase tracking-wide text-slate-400">
                  Label
                  <input
                    value={selectedTemplate.label}
                    onChange={(event) =>
                      updateSelectedTemplate({
                        ...selectedTemplate,
                        label: event.target.value,
                      })
                    }
                    className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  />
                </label>
              </div>

              <div className="mt-4 grid gap-3 sm:grid-cols-2">
                <label className="text-xs uppercase tracking-wide text-slate-400">
                  Overlay Key
                  <input
                    value={selectedTemplate.overlayKey ?? ''}
                    onChange={(event) =>
                      updateSelectedTemplate({
                        ...selectedTemplate,
                        overlayKey: event.target.value.trim() || undefined,
                      })
                    }
                    placeholder="config/tournaments/.../overlays/..."
                    className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  />
                </label>
                <label className="text-xs uppercase tracking-wide text-slate-400">
                  Overlay Placement
                  <div className="mt-2 flex rounded-full border border-white/10 bg-slate-950/60 p-1 text-xs text-white">
                    {['belowText', 'aboveText'].map((placement) => {
                      const active = (selectedTemplate.overlayPlacement ?? 'belowText') === placement
                      return (
                        <button
                          key={placement}
                          type="button"
                          onClick={() =>
                            updateSelectedTemplate({
                              ...selectedTemplate,
                              overlayPlacement: placement as 'belowText' | 'aboveText',
                            })
                          }
                          className={`flex-1 rounded-full px-3 py-1 ${
                            active ? 'bg-white/10 text-white' : 'text-slate-400'
                          }`}
                        >
                          {placement === 'belowText' ? 'Below Text' : 'Above Text'}
                        </button>
                      )
                    })}
                  </div>
                </label>
              </div>

              <div className="mt-4 rounded-2xl border border-white/10 bg-slate-950/60 p-3">
                <div className="flex flex-wrap items-center justify-between gap-3">
                  <div>
                    <div className="text-xs uppercase tracking-[0.2em] text-slate-400">Overlay Upload</div>
                    <p className="mt-1 text-xs text-slate-500">PNG only · 825×1125 recommended.</p>
                  </div>
                  {selectedTemplate.overlayKey ? (
                    <button
                      type="button"
                      onClick={() => navigator.clipboard.writeText(selectedTemplate.overlayKey ?? '')}
                      className="rounded-full border border-white/20 px-3 py-1 text-[11px] text-slate-200"
                    >
                      Copy Key
                    </button>
                  ) : null}
                </div>
                <input
                  type="file"
                  accept="image/png"
                  className="mt-3 text-xs text-slate-300"
                  onChange={(event) => handleOverlayFile(event.target.files?.[0] ?? null)}
                />
                {overlayWarning ? (
                  <p className="mt-2 text-xs text-amber-300">{overlayWarning}</p>
                ) : null}
                {overlayError ? (
                  <p className="mt-2 text-xs text-rose-300">{overlayError}</p>
                ) : null}
                <button
                  type="button"
                  onClick={handleUploadOverlay}
                  disabled={!overlayFile || overlayStatus === 'uploading'}
                  className="mt-3 rounded-full bg-white px-4 py-2 text-xs font-semibold text-slate-900 disabled:opacity-50"
                >
                  {overlayStatus === 'uploading' ? 'Uploading...' : 'Upload Overlay'}
                </button>
              </div>

              <div className="mt-4">
                <div className="flex items-center justify-between">
                  <h4 className="text-xs uppercase tracking-[0.2em] text-slate-400">Theme Colors</h4>
                  <button
                    type="button"
                    onClick={() =>
                      updateSelectedTemplate({
                        ...selectedTemplate,
                        theme: undefined,
                      })
                    }
                    className="text-[11px] text-slate-400 hover:text-slate-200"
                  >
                    Reset Theme
                  </button>
                </div>
                <div className="mt-3 grid gap-3 sm:grid-cols-2">
                  {THEME_FIELDS.map((field) => {
                    const value = selectedTemplate.theme?.[field] ?? BASE_THEME[field]
                    const hexValue = toHex(value) ?? '#ffffff'
                    return (
                      <label key={field} className="text-xs uppercase tracking-wide text-slate-400">
                        {field}
                        <div className="mt-2 flex items-center gap-2">
                          <input
                            type="color"
                            value={hexValue}
                            onChange={(event) =>
                              updateSelectedTemplate({
                                ...selectedTemplate,
                                theme: {
                                  ...selectedTemplate.theme,
                                  [field]: event.target.value,
                                },
                              })
                            }
                            className="h-9 w-9 rounded-md border border-white/10 bg-slate-950/60"
                          />
                          <input
                            value={value}
                            onChange={(event) =>
                              updateSelectedTemplate({
                                ...selectedTemplate,
                                theme: {
                                  ...selectedTemplate.theme,
                                  [field]: event.target.value,
                                },
                              })
                            }
                            className="w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                          />
                        </div>
                      </label>
                    )
                  })}
                </div>
              </div>

              <div className="mt-4">
                <div className="flex items-center justify-between">
                  <h4 className="text-xs uppercase tracking-[0.2em] text-slate-400">Flags</h4>
                  <button
                    type="button"
                    onClick={() =>
                      updateSelectedTemplate({
                        ...selectedTemplate,
                        flags: undefined,
                      })
                    }
                    className="text-[11px] text-slate-400 hover:text-slate-200"
                  >
                    Reset Flags
                  </button>
                </div>
                <div className="mt-3 grid gap-3 sm:grid-cols-2">
                  {FLAG_FIELDS.map((flag) => {
                    const value = selectedTemplate.flags?.[flag] ?? true
                    return (
                      <label key={flag} className="flex items-center justify-between rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-xs text-white">
                        <span>{flag}</span>
                        <input
                          type="checkbox"
                          checked={value}
                          onChange={(event) =>
                            updateSelectedTemplate({
                              ...selectedTemplate,
                              flags: {
                                ...selectedTemplate.flags,
                                [flag]: event.target.checked,
                              },
                            })
                          }
                        />
                      </label>
                    )
                  })}
                </div>
              </div>

              <div className="mt-6 rounded-2xl border border-white/10 bg-slate-950/60 p-4">
                <h4 className="text-xs uppercase tracking-[0.2em] text-slate-400">Default Assignments</h4>
                <label className="mt-3 block text-xs uppercase tracking-wide text-slate-400">
                  Fallback Template
                  <select
                    value={defaults?.fallback ?? ''}
                    onChange={(event) => {
                      const fallback = event.target.value
                      onChange({
                        ...config,
                        defaultTemplates: {
                          fallback,
                          byCardType: defaults?.byCardType ?? {},
                        },
                      })
                    }}
                    className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  >
                    {templates.map((template) => (
                      <option key={template.id} value={template.id}>
                        {template.label}
                      </option>
                    ))}
                  </select>
                </label>
                <div className="mt-3 space-y-2">
                  {config.cardTypes.map((entry) => (
                    <div key={entry.type} className="flex items-center justify-between gap-3 text-xs text-slate-300">
                      <div>
                        <div className="text-white">{entry.label}</div>
                        <div className="text-[11px] text-slate-500">{entry.type}</div>
                      </div>
                      <select
                        value={defaults?.byCardType?.[entry.type] ?? ''}
                        onChange={(event) => {
                          const value = event.target.value
                          const nextByCardType = { ...(defaults?.byCardType ?? {}) }
                          if (!value) {
                            delete nextByCardType[entry.type]
                          } else {
                            nextByCardType[entry.type] = value
                          }
                          onChange({
                            ...config,
                            defaultTemplates: {
                              fallback: defaults?.fallback ?? templates[0]?.id ?? 'classic',
                              byCardType: nextByCardType,
                            },
                          })
                        }}
                        className="rounded-lg border border-white/10 bg-slate-950/60 px-2 py-1 text-xs text-white"
                      >
                        <option value="">Use fallback</option>
                        {templates.map((template) => (
                          <option key={template.id} value={template.id}>
                            {template.label}
                          </option>
                        ))}
                      </select>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          ) : (
            <div className="rounded-2xl border border-white/10 bg-slate-950/40 p-4 text-xs text-slate-400">
              Add a template to start editing.
            </div>
          )}
        </div>

        <div className="lg:sticky lg:top-6 lg:self-start">
          {selectedTemplate ? (
            <TemplatePreview
              config={config}
              templateId={selectedTemplate.id}
              templateLabel={selectedTemplate.label}
            />
          ) : (
            <div className="rounded-3xl border border-white/10 bg-white/5 p-6 text-xs text-slate-400">
              Select a template to preview it.
            </div>
          )}
        </div>
      </div>
    </section>
  )
}
</file>

<file path="client/src/components/TemplatePreview.tsx">
import { useEffect, useMemo, useState } from 'react'
import { CARD_ASPECT, type Card, type CardType, type TournamentConfig } from 'shared'
import { renderCard } from '../renderCard'
import { assetUrlForKey } from '../api'

const PREVIEW_IMAGE_URL = (() => {
  const svg = `
<svg xmlns="http://www.w3.org/2000/svg" width="825" height="1125" viewBox="0 0 825 1125">
  <defs>
    <linearGradient id="bg" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0%" stop-color="#0f172a" />
      <stop offset="55%" stop-color="#1e293b" />
      <stop offset="100%" stop-color="#020617" />
    </linearGradient>
    <radialGradient id="glow" cx="0.2" cy="0.2" r="0.9">
      <stop offset="0%" stop-color="#22c55e" stop-opacity="0.35" />
      <stop offset="100%" stop-color="#0f172a" stop-opacity="0" />
    </radialGradient>
  </defs>
  <rect width="825" height="1125" fill="url(#bg)" />
  <rect width="825" height="1125" fill="url(#glow)" />
  <g opacity="0.25" fill="#38bdf8">
    <circle cx="690" cy="180" r="90" />
    <circle cx="520" cy="320" r="30" />
  </g>
  <g opacity="0.2" fill="#f97316">
    <circle cx="130" cy="860" r="140" />
  </g>
</svg>`

  return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`
})()

const buildSampleCard = (config: TournamentConfig, cardType: CardType, templateId: string): Card => {
  const now = new Date().toISOString()
  const team = config.teams[0]
  const typeConfig = config.cardTypes.find((entry) => entry.type === cardType)
  const position = typeConfig?.positions?.[0] ?? 'Position'

  if (cardType === 'rare') {
    return {
      id: 'preview',
      tournamentId: config.id,
      cardType: 'rare',
      status: 'draft',
      createdAt: now,
      updatedAt: now,
      templateId,
      title: 'Championship MVP',
      caption: 'Limited edition showcase',
      photographer: 'Sample Photographer',
      photo: { crop: { x: 0, y: 0, w: 1, h: 1, rotateDeg: 0 } },
    }
  }

  return {
    id: 'preview',
    tournamentId: config.id,
    cardType,
    status: 'draft',
    createdAt: now,
    updatedAt: now,
    templateId,
    firstName: 'Jordan',
    lastName: 'Lopez',
    position,
    jerseyNumber: '12',
    teamId: cardType === 'player' || cardType === 'team-staff' ? team?.id : undefined,
    teamName: cardType === 'player' || cardType === 'team-staff' ? team?.name : undefined,
    photographer: 'Sample Photographer',
    photo: { crop: { x: 0, y: 0, w: 1, h: 1, rotateDeg: 0 } },
  }
}

type TemplatePreviewProps = {
  config: TournamentConfig
  templateId: string
  templateLabel: string
}

export default function TemplatePreview({ config, templateId, templateLabel }: TemplatePreviewProps) {
  const enabledCardTypes = useMemo(
    () => config.cardTypes.filter((entry) => entry.enabled).map((entry) => entry.type),
    [config.cardTypes]
  )
  const [cardType, setCardType] = useState<CardType>(enabledCardTypes[0] ?? 'player')
  const [previewUrl, setPreviewUrl] = useState<string | null>(null)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (!enabledCardTypes.includes(cardType)) {
      setCardType(enabledCardTypes[0] ?? 'player')
    }
  }, [cardType, enabledCardTypes])

  useEffect(() => {
    if (!templateId) return

    let cancelled = false
    const run = async () => {
      try {
        const card = buildSampleCard(config, cardType, templateId)
        const blob = await renderCard({
          card,
          config,
          imageUrl: PREVIEW_IMAGE_URL,
          resolveAssetUrl: assetUrlForKey,
          templateId,
        })
        if (cancelled) return
        const url = URL.createObjectURL(blob)
        setPreviewUrl((prev) => {
          if (prev) URL.revokeObjectURL(prev)
          return url
        })
        setError(null)
      } catch {
        if (!cancelled) {
          setError('Preview failed to render')
        }
      }
    }

    run()

    return () => {
      cancelled = true
    }
  }, [cardType, config, templateId])

  return (
    <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
      <div className="flex items-center justify-between gap-3">
        <div>
          <h3 className="text-sm uppercase tracking-[0.2em] text-slate-400">Live Preview</h3>
          <div className="mt-1 text-xs text-slate-500">
            {templateLabel} · {templateId}
          </div>
        </div>
        <div className="flex flex-wrap gap-2">
          {enabledCardTypes.map((type) => (
            <button
              key={type}
              type="button"
              onClick={() => setCardType(type)}
              className={`rounded-full border px-3 py-1 text-[11px] uppercase tracking-[0.2em] ${
                cardType === type
                  ? 'border-emerald-500/50 bg-emerald-500/10 text-emerald-200'
                  : 'border-white/10 text-slate-400'
              }`}
            >
              {type}
            </button>
          ))}
        </div>
      </div>

      <div className="mt-4">
        {previewUrl ? (
          <img
            src={previewUrl}
            alt="Template preview"
            className="w-full rounded-2xl shadow-lg"
            style={{ aspectRatio: `${CARD_ASPECT}` }}
          />
        ) : (
          <div className="flex aspect-[825/1125] items-center justify-center rounded-2xl border border-dashed border-white/10 text-xs text-slate-500">
            {error ?? 'Rendering preview...'}
          </div>
        )}
      </div>
      <p className="mt-3 text-xs text-slate-500">
        Preview uses sample data and a placeholder photo.
      </p>
    </div>
  )
}
</file>

<file path="shared/src/templates.ts">
import type { CardType, TemplateDefinition, TournamentConfig } from "./types"

export const DEFAULT_TEMPLATE_ID = "classic"

export const resolveTemplateId = (
  input: { templateId?: string | null; cardType?: CardType },
  config?: TournamentConfig | null
) => {
  const direct = typeof input.templateId === "string" ? input.templateId.trim() : ""
  if (direct) return direct

  const cardType = input.cardType
  const byType = cardType ? config?.defaultTemplates?.byCardType?.[cardType] : undefined
  if (byType) return byType

  const fallback = config?.defaultTemplates?.fallback
  if (fallback) return fallback

  return DEFAULT_TEMPLATE_ID
}

export const findTemplate = (
  config: TournamentConfig | null | undefined,
  templateId: string | null | undefined
): TemplateDefinition | null => {
  if (!config?.templates || !templateId) return null
  return config.templates.find((template) => template.id === templateId) ?? null
}
</file>

<file path=".husky/pre-commit">
# Type check and lint before commit
pnpm type-check
pnpm lint-staged
</file>

<file path="client/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="client/src/draftStorage.ts">
/**
 * localStorage persistence for card drafts.
 * Stores cardId, editToken, and form data so users can resume after refresh.
 */

const STORAGE_KEY = 'trading-card-draft'

export type SavedDraft = {
  cardId: string
  editToken: string
  tournamentId: string
  cardType: string
  form: {
    teamId: string
    position: string
    jerseyNumber: string
    firstName: string
    lastName: string
    title: string
    caption: string
    photographer: string
    templateId: string
  }
  savedAt: string
}

export function saveDraft(draft: SavedDraft): void {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(draft))
  } catch {
    // localStorage might be full or disabled - fail silently
  }
}

export function loadDraft(): SavedDraft | null {
  try {
    const stored = localStorage.getItem(STORAGE_KEY)
    if (!stored) return null

    const draft = JSON.parse(stored) as SavedDraft

    // Basic validation
    if (!draft.cardId || !draft.editToken || !draft.tournamentId) {
      clearDraft()
      return null
    }

    return draft
  } catch {
    clearDraft()
    return null
  }
}

export function clearDraft(): void {
  try {
    localStorage.removeItem(STORAGE_KEY)
  } catch {
    // fail silently
  }
}
</file>

<file path="server/src/dev.ts">
import { serve } from '@hono/node-server'
import app from './index.js'

const port = Number(process.env.PORT ?? 3000)

console.log(`Hono dev server running on http://localhost:${port}`)

serve({
  fetch: app.fetch,
  port,
})
</file>

<file path="server/src/lambda.ts">
import { handle } from 'hono/aws-lambda'
import app from './index.js'

export const handler = handle(app)
</file>

<file path="shared/src/constants.ts">
// Card render dimensions - single source of truth
export const CARD_WIDTH = 825
export const CARD_HEIGHT = 1125
export const CARD_ASPECT = CARD_WIDTH / CARD_HEIGHT // ~0.7333

// Print geometry at 300 DPI (1/8" = 37.5px)
export const TRIM_INSET_PX = 37.5
export const SAFE_INSET_PX = 75

export const TRIM_BOX = { x: 37.5, y: 37.5, w: 750, h: 1050 }
export const SAFE_BOX = { x: 75, y: 75, w: 675, h: 975 }

// Percentages for responsive overlay
export const GUIDE_PERCENTAGES = {
  trim: { left: 4.545, top: 3.333, right: 4.545, bottom: 3.333 },
  safe: { left: 9.091, top: 6.667, right: 9.091, bottom: 6.667 },
}
</file>

<file path="shared/src/validation.ts">
export const MAX_UPLOAD_BYTES = 15 * 1024 * 1024

export const ALLOWED_UPLOAD_TYPES = [
  'image/jpeg',
  'image/png',
  'image/webp',
] as const

export const ALLOWED_RENDER_TYPES = ['image/png'] as const

export const MAX_NAME_LENGTH = 24
export const MAX_TITLE_LENGTH = 48
export const MAX_CAPTION_LENGTH = 120
export const MAX_PHOTOGRAPHER_LENGTH = 48
export const MAX_TEAM_LENGTH = 64
export const MAX_POSITION_LENGTH = 32
export const MAX_JERSEY_LENGTH = 2

export const JERSEY_PATTERN = /^\d{1,2}$/
</file>

<file path="pnpm-workspace.yaml">
packages:
  - client
  - server
  - shared

onlyBuiltDependencies:
  - aws-sdk
  - esbuild
</file>

<file path="client/src/api.ts">
// Shared API utilities for client-side requests.

const API_BASE =
  import.meta.env.DEV && import.meta.env.VITE_API_URL
    ? import.meta.env.VITE_API_URL.replace(/\/$/, '')
    : '/api'

const MEDIA_BASE =
  import.meta.env.DEV && import.meta.env.VITE_ROUTER_URL
    ? import.meta.env.VITE_ROUTER_URL.replace(/\/$/, '')
    : ''

export const api = (path: string) => `${API_BASE}${path}`
export const media = (path: string) => `${MEDIA_BASE}${path}`
export const writeHeaders: HeadersInit = {}

export const publicPathForKey = (key: string) => {
  if (key.startsWith('renders/')) return `/r/${key.slice('renders/'.length)}`
  if (key.startsWith('config/')) return `/c/${key.slice('config/'.length)}`
  return `/${key}`
}

export const assetUrlForKey = (key: string) => media(publicPathForKey(key))
</file>

<file path="client/src/index.css">
@import url('https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400..700&family=Sora:wght@300..700&display=swap');
@import "tailwindcss";

:root {
  --font-sans: "Sora", "Avenir Next", "Helvetica Neue", sans-serif;
  --font-display: "Fraunces", "Iowan Old Style", serif;
  --ink: #eef2ff;
  --muted: #94a3b8;
  --panel: rgba(255, 255, 255, 0.06);
}

body {
  font-family: var(--font-sans);
  color: var(--ink);
  background-color: #0b0f1a;
}

.font-display {
  font-family: var(--font-display);
  letter-spacing: -0.02em;
}

.app-shell {
  background:
    radial-gradient(60rem 60rem at -10% -15%, rgba(94, 234, 212, 0.2), transparent 55%),
    radial-gradient(45rem 45rem at 110% 10%, rgba(248, 113, 113, 0.18), transparent 55%),
    radial-gradient(35rem 35rem at 50% 120%, rgba(129, 140, 248, 0.2), transparent 60%),
    linear-gradient(135deg, rgba(15, 23, 42, 0.85), rgba(2, 6, 23, 0.95));
}

.cropper-container {
  border-radius: 1.5rem;
}

.cropper-area {
  border: 1px solid rgba(255, 255, 255, 0.65);
  box-shadow: 0 0 0 9999px rgba(2, 6, 23, 0.7);
}

@keyframes celebrate-pop {
  0% {
    opacity: 0;
    transform: scale(0.92);
  }
  40% {
    opacity: 0.9;
    transform: scale(1.02);
  }
  100% {
    opacity: 0;
    transform: scale(1.06);
  }
}

.celebrate {
  position: relative;
  overflow: hidden;
}

.celebrate::after {
  content: "";
  position: absolute;
  inset: -20%;
  background:
    radial-gradient(circle at 20% 30%, rgba(16, 185, 129, 0.35), transparent 45%),
    radial-gradient(circle at 80% 40%, rgba(56, 189, 248, 0.25), transparent 50%),
    radial-gradient(circle at 50% 70%, rgba(251, 191, 36, 0.2), transparent 55%);
  opacity: 0;
  animation: celebrate-pop 1.4s ease-out;
  pointer-events: none;
}
</file>

<file path="client/src/router.tsx">
import { createRootRoute, createRoute, createRouter, Outlet } from '@tanstack/react-router'
import App from './App'
import Admin from './Admin'

const rootRoute = createRootRoute({
  component: () => <Outlet />,
})

const indexRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/',
  component: App,
})

const adminRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/admin',
  component: Admin,
})

const routeTree = rootRoute.addChildren([indexRoute, adminRoute])

export const router = createRouter({ routeTree })
</file>

<file path="client/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Trading Card Studio</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": ".",
  "version": "0.5.1",
  "description": "A monorepo app built with Hono, Vite, and React",
  "author": "Steve Simkins",
  "license": "MIT",
  "homepage": "https://github.com/stevedylandev/bhvr",
  "packageManager": "pnpm@10.15.0",
  "workspaces": [
    "./server",
    "./client",
    "./shared"
  ],
  "scripts": {
    "build": "turbo build",
    "build:client": "turbo build --filter=client",
    "build:server": "turbo build --filter=server",
    "dev": "turbo dev",
    "dev:client": "turbo dev --filter=client",
    "dev:server": "turbo dev --filter=server",
    "lint": "turbo lint",
    "postinstall": "turbo build --filter=shared --filter=server",
    "test": "turbo test",
    "type-check": "turbo type-check",
    "prepare": "husky"
  },
  "keywords": [
    "hono",
    "react",
    "vite",
    "monorepo",
    "turbo"
  ],
  "devDependencies": {
    "@eslint/js": "^9.39.2",
    "@types/aws-lambda": "8.10.159",
    "eslint": "^9.39.2",
    "globals": "^16.5.0",
    "husky": "^9.1.7",
    "lint-staged": "^16.2.7",
    "turbo": "^2.5.5",
    "typescript-eslint": "^8.50.0"
  },
  "peerDependencies": {
    "typescript": "^5.7.3"
  },
  "dependencies": {
    "sst": "3.17.25"
  },
  "lint-staged": {
    "client/src/**/*.{ts,tsx}": [
      "eslint --fix"
    ],
    "server/src/**/*.ts": [
      "eslint --fix"
    ],
    "shared/src/**/*.ts": [
      "eslint --fix"
    ]
  }
}
</file>

<file path="client/src/Admin.tsx">
import { useEffect, useMemo, useState } from 'react'
import JSZip from 'jszip'
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { resolveTemplateId, type Card, type TournamentConfig, type TournamentListEntry } from 'shared'
import { api, assetUrlForKey } from './api'
import { renderCard, resolveTemplateSnapshot } from './renderCard'
import TemplateEditor from './components/TemplateEditor'

type LogosZipResult = {
  uploaded: string[]
  skipped: Array<{ filename: string; reason: string }>
  missingLogos: string[]
}

type BundleImportResult = {
  tournament: TournamentConfig
  results: {
    configSaved: boolean
    assetsUploaded: string[]
    assetsSkipped: string[]
  }
}

type PresignResponse = {
  uploadUrl: string
  key: string
  method: 'POST' | 'PUT'
  headers?: Record<string, string>
  fields?: Record<string, string>
}

const MAX_UPLOAD_RETRIES = 1

const cardDisplayName = (card: Card) => {
  if (card.cardType === 'rare') {
    return card.title ?? 'Untitled rare card'
  }
  const fullName = [card.firstName, card.lastName].filter(Boolean).join(' ')
  return fullName || 'Unnamed card'
}

// Sanitize filenames for ZIP entries to prevent Zip Slip attacks
const safeZipName = (value: string) =>
  value
    .normalize('NFKD')
    .replace(/[/\\]/g, '-')           // kill path separators
    .replace(/\.\./g, '.')            // kill traversal
    .replace(/[^a-zA-Z0-9._ -]/g, '') // strip weird chars
    .trim()
    .replace(/\s+/g, '-')
    .slice(0, 60) || 'card'

const getUploadFilename = (key: string) => {
  const lastSegment = key.split('/').pop()
  return lastSegment && lastSegment.length > 0 ? lastSegment : 'upload'
}

const toUploadFile = (data: Blob, key: string) =>
  data instanceof File
    ? data
    : new File([data], getUploadFilename(key), {
        type: data.type || 'application/octet-stream',
      })

async function uploadToS3(presign: PresignResponse, data: Blob): Promise<void> {
  const uploadOnce = async () => {
    if (presign.method === 'POST') {
      if (!presign.fields) {
        throw new Error('Upload fields are missing')
      }
      const formData = new FormData()
      for (const [key, value] of Object.entries(presign.fields)) {
        formData.append(key, value)
      }
      formData.append('file', toUploadFile(data, presign.key))
      const res = await fetch(presign.uploadUrl, { method: 'POST', body: formData })
      if (!res.ok) throw new Error('Upload failed')
      return
    }

    const res = await fetch(presign.uploadUrl, {
      method: presign.method,
      headers: presign.headers,
      body: data,
    })
    if (!res.ok) throw new Error('Upload failed')
  }

  let lastError: unknown = null
  for (let attempt = 0; attempt <= MAX_UPLOAD_RETRIES; attempt++) {
    try {
      await uploadOnce()
      return
    } catch (err) {
      lastError = err
    }
  }

  if (lastError instanceof Error) throw lastError
  throw new Error('Upload failed')
}

export default function Admin() {
  const queryClient = useQueryClient()
  const [passwordInput, setPasswordInput] = useState('')
  const [adminPassword, setAdminPassword] = useState(() => sessionStorage.getItem('adminPassword') ?? '')
  const [activeTournamentId, setActiveTournamentId] = useState('')
  const [configDraft, setConfigDraft] = useState('')
  const [statusFilter, setStatusFilter] = useState('submitted')
  const [logosZipFile, setLogosZipFile] = useState<File | null>(null)
  const [logosZipResult, setLogosZipResult] = useState<LogosZipResult | null>(null)
  const [bundleFile, setBundleFile] = useState<File | null>(null)
  const [bundleResult, setBundleResult] = useState<BundleImportResult | null>(null)
  const [renderingCardId, setRenderingCardId] = useState<string | null>(null)

  // Save password to sessionStorage when it changes
  useEffect(() => {
    if (adminPassword) {
      sessionStorage.setItem('adminPassword', adminPassword)
    }
  }, [adminPassword])

  const handleLogin = () => {
    if (passwordInput.trim()) {
      setAdminPassword(passwordInput.trim())
    }
  }

  // Auth headers for admin API calls
  const adminHeaders = useMemo(() => ({
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${adminPassword}`,
  }), [adminPassword])

  const tournamentsQuery = useQuery({
    queryKey: ['admin-tournaments', adminPassword],
    queryFn: async () => {
      const res = await fetch(api('/admin/tournaments'), { headers: adminHeaders })
      if (!res.ok) throw new Error('Request failed')
      return res.json() as Promise<TournamentListEntry[]>
    },
    enabled: Boolean(adminPassword),
  })

  useEffect(() => {
    if (!activeTournamentId && tournamentsQuery.data?.length) {
      setActiveTournamentId(tournamentsQuery.data[0].id)
    }
  }, [activeTournamentId, tournamentsQuery.data])

  const configQuery = useQuery({
    queryKey: ['admin-config', activeTournamentId, adminPassword],
    queryFn: async () => {
      const res = await fetch(api(`/admin/tournaments/${activeTournamentId}`), { headers: adminHeaders })
      if (!res.ok) throw new Error('Request failed')
      return res.json() as Promise<TournamentConfig>
    },
    enabled: Boolean(activeTournamentId) && Boolean(adminPassword),
  })

  useEffect(() => {
    if (configQuery.data) {
      setConfigDraft(JSON.stringify(configQuery.data, null, 2))
    }
  }, [configQuery.data])

  const configParsed = useMemo(() => {
    try {
      return JSON.parse(configDraft) as TournamentConfig
    } catch {
      return null
    }
  }, [configDraft])

  const activeConfig = configParsed ?? configQuery.data ?? null

  const templateOptions = useMemo(() => {
    if (activeConfig?.templates && activeConfig.templates.length > 0) {
      return activeConfig.templates
    }
    return [
      { id: 'classic', label: 'Classic' },
      { id: 'noir', label: 'Noir' },
    ]
  }, [activeConfig])

  const templateLabelFor = (templateId: string) =>
    templateOptions.find((template) => template.id === templateId)?.label ?? templateId

  const uploadOverlay = async (templateId: string, file: File) => {
    if (!activeTournamentId) {
      throw new Error('Select a tournament first')
    }
    if (!adminPassword) {
      throw new Error('Admin password is required')
    }
    const res = await fetch(api(`/admin/tournaments/${activeTournamentId}/assets/presign`), {
      method: 'POST',
      headers: adminHeaders,
      body: JSON.stringify({
        kind: 'templateOverlay',
        templateId,
        contentType: file.type,
      }),
    })
    if (!res.ok) {
      const error = await res.json().catch(() => ({}))
      throw new Error(error.error ?? 'Presign failed')
    }
    const presign = await res.json() as PresignResponse
    await uploadToS3(presign, file)
    return presign.key
  }

  const cardsQuery = useQuery({
    queryKey: ['admin-cards', statusFilter, activeTournamentId, adminPassword],
    queryFn: async () => {
      const params = new URLSearchParams({ status: statusFilter })
      if (activeTournamentId) params.set('tournamentId', activeTournamentId)
      const res = await fetch(api(`/admin/cards?${params}`), { headers: adminHeaders })
      if (!res.ok) throw new Error('Request failed')
      return res.json() as Promise<Card[]>
    },
    enabled: Boolean(adminPassword),
  })

  const saveConfigMutation = useMutation({
    mutationFn: async () => {
      const parsed = JSON.parse(configDraft) as TournamentConfig
      const res = await fetch(api(`/admin/tournaments/${activeTournamentId}`), {
        method: 'PUT',
        headers: adminHeaders,
        body: JSON.stringify(parsed),
      })
      if (!res.ok) {
        const error = await res.json().catch(() => ({}))
        throw new Error(error.error ?? 'Request failed')
      }
      return res.json() as Promise<TournamentConfig>
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-config', activeTournamentId] })
    },
  })

  const publishMutation = useMutation({
    mutationFn: async () => {
      const res = await fetch(api(`/admin/tournaments/${activeTournamentId}/publish`), {
        method: 'POST',
        headers: adminHeaders,
        body: JSON.stringify({}),
      })
      if (!res.ok) {
        const error = await res.json().catch(() => ({}))
        throw new Error(error.error ?? 'Request failed')
      }
      return res.json()
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-tournaments'] })
    },
  })

  const logosZipMutation = useMutation({
    mutationFn: async () => {
      if (!logosZipFile) throw new Error('Select a ZIP file')
      const res = await fetch(api(`/admin/tournaments/${activeTournamentId}/logos-zip`), {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${adminPassword}` },
        body: logosZipFile,
      })
      if (!res.ok) {
        const error = await res.json().catch(() => ({}))
        throw new Error(error.error ?? 'Upload failed')
      }
      return res.json() as Promise<LogosZipResult>
    },
    onSuccess: (data) => {
      setLogosZipResult(data)
      setLogosZipFile(null)
    },
  })

  const bundleImportMutation = useMutation({
    mutationFn: async () => {
      if (!bundleFile) throw new Error('Select a ZIP file')
      const res = await fetch(api('/admin/tournaments/import-bundle'), {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${adminPassword}` },
        body: bundleFile,
      })
      if (!res.ok) {
        const error = await res.json().catch(() => ({}))
        throw new Error(error.error ?? 'Import failed')
      }
      return res.json() as Promise<BundleImportResult>
    },
    onSuccess: (data) => {
      setBundleResult(data)
      setBundleFile(null)
      setActiveTournamentId(data.tournament.id)
      queryClient.invalidateQueries({ queryKey: ['admin-tournaments'] })
      queryClient.invalidateQueries({ queryKey: ['admin-config'] })
    },
  })

  const templateMutation = useMutation({
    mutationFn: async ({ id, templateId }: { id: string; templateId: string | null }) => {
      const res = await fetch(api(`/admin/cards/${id}`), {
        method: 'PATCH',
        headers: adminHeaders,
        body: JSON.stringify({ templateId }),
      })
      if (!res.ok) {
        const error = await res.json().catch(() => ({}))
        throw new Error(error.error ?? 'Request failed')
      }
      return res.json()
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-cards', statusFilter, activeTournamentId] })
    },
  })

  const renderMutation = useMutation({
    mutationFn: async (card: Card) => {
      if (!activeConfig) {
        throw new Error('Tournament config is not available')
      }

      const photoRes = await fetch(api(`/admin/cards/${card.id}/photo-url`), {
        headers: { 'Authorization': `Bearer ${adminPassword}` },
      })
      if (!photoRes.ok) {
        const error = await photoRes.json().catch(() => ({}))
        throw new Error(error.error ?? 'Photo request failed')
      }
      const photoData = await photoRes.json() as { url: string }

      const { templateId, templateSnapshot } = resolveTemplateSnapshot({
        card,
        config: activeConfig,
      })

      const blob = await renderCard({
        card,
        config: activeConfig,
        imageUrl: photoData.url,
        resolveAssetUrl: assetUrlForKey,
        templateId,
      })

      const presignRes = await fetch(api(`/admin/cards/${card.id}/renders/presign`), {
        method: 'POST',
        headers: adminHeaders,
        body: JSON.stringify({
          contentType: blob.type || 'image/png',
          contentLength: blob.size,
        }),
      })
      if (!presignRes.ok) {
        const error = await presignRes.json().catch(() => ({}))
        throw new Error(error.error ?? 'Render presign failed')
      }
      const presign = await presignRes.json() as PresignResponse

      await uploadToS3(presign, blob)

      const renderMeta = {
        key: presign.key,
        templateId,
        renderedAt: new Date().toISOString(),
        templateSnapshot,
      }

      const commitRes = await fetch(api(`/admin/cards/${card.id}/renders/commit`), {
        method: 'POST',
        headers: adminHeaders,
        body: JSON.stringify({ renderKey: presign.key, renderMeta }),
      })
      if (!commitRes.ok) {
        const error = await commitRes.json().catch(() => ({}))
        throw new Error(error.error ?? 'Render commit failed')
      }
      return commitRes.json()
    },
    onMutate: (card) => {
      setRenderingCardId(card.id)
    },
    onSettled: () => {
      setRenderingCardId(null)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-cards', statusFilter, activeTournamentId] })
    },
  })

  const deleteMutation = useMutation({
    mutationFn: async (id: string) => {
      const res = await fetch(api(`/admin/cards/${id}`), {
        method: 'DELETE',
        headers: { 'Authorization': `Bearer ${adminPassword}` },
      })
      if (!res.ok) {
        const error = await res.json().catch(() => ({}))
        throw new Error(error.error ?? 'Delete failed')
      }
      return res.json()
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin-cards', statusFilter, activeTournamentId] })
    },
  })

  // Show loading state while verifying password
  if (adminPassword && tournamentsQuery.isPending) {
    return (
      <div className="app-shell min-h-screen">
        <div className="mx-auto flex max-w-md flex-col items-center justify-center px-6 py-24">
          <div className="w-full rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur">
            <h1 className="font-display text-3xl text-white text-center">Admin Console</h1>
            <p className="mt-2 text-sm text-slate-400 text-center">
              Verifying credentials...
            </p>
          </div>
        </div>
      </div>
    )
  }

  // Show login screen when no password entered
  if (!adminPassword) {
    return (
      <div className="app-shell min-h-screen">
        <div className="mx-auto flex max-w-md flex-col items-center justify-center px-6 py-24">
          <div className="w-full rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur">
            <h1 className="font-display text-3xl text-white text-center">Admin Console</h1>
            <p className="mt-2 text-sm text-slate-400 text-center">
              Enter the admin password to continue.
            </p>
            <form
              className="mt-6"
              onSubmit={(e) => {
                e.preventDefault()
                handleLogin()
              }}
            >
              <label htmlFor="admin-password" className="block text-xs text-slate-400 mb-2">
                Password
              </label>
              <input
                id="admin-password"
                type="password"
                value={passwordInput}
                onChange={(e) => setPasswordInput(e.target.value)}
                placeholder="Enter admin password"
                className="w-full rounded-xl border border-white/20 bg-slate-950/50 px-4 py-3 text-sm text-white placeholder:text-slate-500"
                autoFocus
              />
              <button
                type="submit"
                disabled={!passwordInput.trim()}
                className="mt-4 w-full rounded-xl bg-white px-4 py-3 text-sm font-semibold text-slate-900 disabled:opacity-50"
              >
                Sign In
              </button>
            </form>
          </div>
        </div>
      </div>
    )
  }

  // Show error state if password is wrong
  if (tournamentsQuery.isError) {
    return (
      <div className="app-shell min-h-screen">
        <div className="mx-auto flex max-w-md flex-col items-center justify-center px-6 py-24">
          <div className="w-full rounded-3xl border border-rose-500/20 bg-rose-500/5 p-8 backdrop-blur">
            <h1 className="font-display text-3xl text-white text-center">Access Denied</h1>
            <p className="mt-2 text-sm text-rose-400 text-center">
              Invalid password. Please try again.
            </p>
            <form
              className="mt-6"
              onSubmit={(e) => {
                e.preventDefault()
                handleLogin()
              }}
            >
              <label htmlFor="admin-password" className="block text-xs text-slate-400 mb-2">
                Password
              </label>
              <input
                id="admin-password"
                type="password"
                value={passwordInput}
                onChange={(e) => setPasswordInput(e.target.value)}
                placeholder="Enter admin password"
                className="w-full rounded-xl border border-white/20 bg-slate-950/50 px-4 py-3 text-sm text-white placeholder:text-slate-500"
                autoFocus
              />
              <button
                type="submit"
                disabled={!passwordInput.trim()}
                className="mt-4 w-full rounded-xl bg-white px-4 py-3 text-sm font-semibold text-slate-900 disabled:opacity-50"
              >
                Sign In
              </button>
            </form>
            <button
              type="button"
              onClick={() => {
                setAdminPassword('')
                setPasswordInput('')
                sessionStorage.removeItem('adminPassword')
                queryClient.invalidateQueries({ queryKey: ['admin-tournaments'] })
              }}
              className="mt-4 w-full rounded-xl border border-white/20 px-4 py-2 text-xs text-slate-400 hover:bg-white/5"
            >
              Clear and try again
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="app-shell min-h-screen">
      <div className="mx-auto flex max-w-6xl flex-col gap-8 px-6 py-12">
        <header className="flex flex-wrap items-start justify-between gap-4">
          <div>
            <h1 className="font-display text-4xl text-white">Admin Console</h1>
            <p className="text-sm text-slate-400">
              Manage tournaments, upload assets, and review submissions.
            </p>
          </div>
          <div className="flex items-center gap-3">
            <span className="flex items-center gap-1.5 text-xs text-emerald-400">
              <span className="h-2 w-2 rounded-full bg-emerald-400" />
              Authenticated
            </span>
            <button
              type="button"
              onClick={() => {
                setAdminPassword('')
                setPasswordInput('')
                sessionStorage.removeItem('adminPassword')
                queryClient.invalidateQueries({ queryKey: ['admin-tournaments'] })
              }}
              className="rounded-full border border-white/20 px-3 py-1 text-xs text-slate-400 hover:bg-white/5"
            >
              Sign out
            </button>
          </div>
        </header>

        <div className="grid gap-8 lg:grid-cols-[1.1fr_0.9fr]">
          <section className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
            <div className="flex flex-wrap items-center justify-between gap-3">
              <h2 className="text-lg font-semibold text-white">Tournament Config</h2>
              <select
                value={activeTournamentId}
                onChange={(event) => setActiveTournamentId(event.target.value)}
                className="rounded-full border border-white/20 bg-slate-950/50 px-3 py-1 text-xs text-white"
              >
                {tournamentsQuery.data?.map((tournament) => (
                  <option key={tournament.id} value={tournament.id}>
                    {tournament.name}
                  </option>
                ))}
              </select>
            </div>
            <textarea
              value={configDraft}
              onChange={(event) => setConfigDraft(event.target.value)}
              className="mt-4 h-72 w-full rounded-2xl border border-white/10 bg-slate-950/60 px-4 py-3 text-xs text-slate-200"
            />
            <div className="mt-4 flex flex-wrap items-center gap-3">
              <button
                type="button"
                onClick={() => saveConfigMutation.mutate()}
                className="rounded-full bg-white px-4 py-2 text-xs font-semibold text-slate-900"
              >
                Save Draft
              </button>
              <button
                type="button"
                onClick={() => publishMutation.mutate()}
                className="rounded-full border border-emerald-500/40 px-4 py-2 text-xs text-emerald-300"
              >
                Publish
              </button>
              <button
                type="button"
                onClick={() => {
                  if (!configParsed) return
                  const blob = new Blob([JSON.stringify(configParsed, null, 2)], { type: 'application/json' })
                  const url = URL.createObjectURL(blob)
                  const link = document.createElement('a')
                  link.href = url
                  link.download = `${activeTournamentId}-config.json`
                  link.click()
                  URL.revokeObjectURL(url)
                }}
                className="rounded-full border border-white/20 px-4 py-2 text-xs text-white"
              >
                Download JSON
              </button>
            </div>
          </section>

          <section className="space-y-6">
            <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
              <h3 className="text-sm uppercase tracking-[0.2em] text-slate-400">Upload Team Logos</h3>
              <p className="mt-2 text-xs text-slate-400">
                Upload a ZIP file containing team logos. Each PNG file should be named with the team ID
                (e.g., <code className="text-emerald-400">boston-kraken.png</code>).
              </p>
              <div className="mt-4 rounded-xl border border-dashed border-white/20 bg-slate-950/40 p-4">
                <p className="text-xs text-slate-500 mb-2">Expected structure:</p>
                <pre className="text-xs text-slate-400 font-mono">
{`logos.zip
├── team-id-1.png
├── team-id-2.png
└── ...`}
                </pre>
              </div>
              <input
                type="file"
                accept=".zip"
                className="mt-4 text-xs text-slate-300"
                onChange={(event) => {
                  setLogosZipFile(event.target.files?.[0] ?? null)
                  setLogosZipResult(null)
                }}
              />
              <button
                type="button"
                onClick={() => logosZipMutation.mutate()}
                disabled={!logosZipFile || logosZipMutation.isPending}
                className="mt-3 rounded-full bg-white px-4 py-2 text-xs font-semibold text-slate-900 disabled:opacity-50"
              >
                {logosZipMutation.isPending ? 'Uploading...' : 'Upload Logos ZIP'}
              </button>
              {logosZipMutation.isError && (
                <p className="mt-2 text-xs text-rose-400">
                  {logosZipMutation.error instanceof Error ? logosZipMutation.error.message : 'Upload failed'}
                </p>
              )}
              {logosZipResult && (
                <div className="mt-4 space-y-2 text-xs">
                  <p className="text-emerald-400">
                    Uploaded: {logosZipResult.uploaded.length} logos
                  </p>
                  {logosZipResult.skipped.length > 0 && (
                    <div className="text-amber-400">
                      <p>Skipped {logosZipResult.skipped.length} files:</p>
                      <ul className="mt-1 ml-4 list-disc text-slate-400">
                        {logosZipResult.skipped.slice(0, 5).map((s, i) => (
                          <li key={i}>{s.filename}: {s.reason}</li>
                        ))}
                        {logosZipResult.skipped.length > 5 && (
                          <li>...and {logosZipResult.skipped.length - 5} more</li>
                        )}
                      </ul>
                    </div>
                  )}
                  {logosZipResult.missingLogos.length > 0 && (
                    <div className="text-rose-400">
                      <p>Teams still missing logos: {logosZipResult.missingLogos.length}</p>
                      <ul className="mt-1 ml-4 list-disc text-slate-400">
                        {logosZipResult.missingLogos.slice(0, 5).map((id) => (
                          <li key={id}>{id}</li>
                        ))}
                        {logosZipResult.missingLogos.length > 5 && (
                          <li>...and {logosZipResult.missingLogos.length - 5} more</li>
                        )}
                      </ul>
                    </div>
                  )}
                </div>
              )}
            </div>

            <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
              <h3 className="text-sm uppercase tracking-[0.2em] text-slate-400">Tournament Bundle</h3>
              <p className="mt-2 text-xs text-slate-400">
                Import or export a complete tournament as a ZIP bundle including config and all assets.
              </p>
              <div className="mt-4 rounded-xl border border-dashed border-white/20 bg-slate-950/40 p-4">
                <p className="text-xs text-slate-500 mb-2">Bundle structure:</p>
                <pre className="text-xs text-slate-400 font-mono">
{`tournament.zip
├── config.json          (required)
├── tournament-logo.png  (optional)
├── org-logo.png         (optional)
└── teams/               (optional)
    ├── team-id-1.png
    └── ...`}
                </pre>
              </div>
              <div className="mt-4 flex flex-wrap gap-3">
                <button
                  type="button"
                  onClick={async () => {
                    const res = await fetch(api(`/admin/tournaments/${activeTournamentId}/bundle`), {
                      headers: { 'Authorization': `Bearer ${adminPassword}` },
                    })
                    if (!res.ok) return
                    const blob = await res.blob()
                    const url = URL.createObjectURL(blob)
                    const link = document.createElement('a')
                    link.href = url
                    link.download = `${activeTournamentId}-bundle.zip`
                    link.click()
                    URL.revokeObjectURL(url)
                  }}
                  className="rounded-full border border-emerald-500/40 px-4 py-2 text-xs text-emerald-300 hover:bg-emerald-500/10"
                >
                  Export Bundle
                </button>
              </div>
              <div className="mt-4 border-t border-white/10 pt-4">
                <p className="text-xs text-slate-500 mb-2">Import a new tournament:</p>
                <input
                  type="file"
                  accept=".zip"
                  className="text-xs text-slate-300"
                  onChange={(event) => {
                    setBundleFile(event.target.files?.[0] ?? null)
                    setBundleResult(null)
                  }}
                />
                <button
                  type="button"
                  onClick={() => bundleImportMutation.mutate()}
                  disabled={!bundleFile || bundleImportMutation.isPending}
                  className="mt-3 rounded-full bg-white px-4 py-2 text-xs font-semibold text-slate-900 disabled:opacity-50"
                >
                  {bundleImportMutation.isPending ? 'Importing...' : 'Import Bundle'}
                </button>
                {bundleImportMutation.isError && (
                  <p className="mt-2 text-xs text-rose-400">
                    {bundleImportMutation.error instanceof Error ? bundleImportMutation.error.message : 'Import failed'}
                  </p>
                )}
                {bundleResult && (
                  <div className="mt-4 space-y-2 text-xs">
                    <p className="text-emerald-400">
                      Imported tournament: {bundleResult.tournament.name}
                    </p>
                    <p className="text-slate-400">
                      Assets uploaded: {bundleResult.results.assetsUploaded.length}
                    </p>
                    {bundleResult.results.assetsSkipped.length > 0 && (
                      <p className="text-amber-400">
                        Skipped: {bundleResult.results.assetsSkipped.join(', ')}
                      </p>
                    )}
                  </div>
                )}
              </div>
            </div>
          </section>
        </div>

        {activeConfig ? (
          <TemplateEditor
            config={activeConfig}
            onChange={(next) => setConfigDraft(JSON.stringify(next, null, 2))}
            uploadOverlay={uploadOverlay}
          />
        ) : (
          <section className="rounded-3xl border border-white/10 bg-white/5 p-6 text-xs text-slate-400">
            Fix the tournament JSON to edit templates.
          </section>
        )}

        <section className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
          <div className="flex flex-wrap items-center justify-between gap-3">
            <h2 className="text-lg font-semibold text-white">Card Review</h2>
            <div className="flex items-center gap-3">
              <button
                type="button"
                onClick={async () => {
                  const cardsWithRenders = cardsQuery.data?.filter((c) => c.renderKey) ?? []
                  if (cardsWithRenders.length === 0) return

                  const zip = new JSZip()

                  for (const card of cardsWithRenders) {
                    const name = card.cardType === 'rare'
                      ? (card.title ?? 'rare-card')
                      : [card.firstName, card.lastName].filter(Boolean).join('-') || 'card'
                    const filename = `${safeZipName(name)}-${card.id.slice(0, 8)}.png`

                    // Use presigned download URL from API to avoid CORS issues
                    const res = await fetch(api(`/admin/cards/${card.id}/download-url`), {
                      headers: { 'Authorization': `Bearer ${adminPassword}` },
                    })
                    if (res.ok) {
                      const { url: downloadUrl } = await res.json()
                      const imageRes = await fetch(downloadUrl)
                      if (imageRes.ok) {
                        const blob = await imageRes.blob()
                        zip.file(filename, blob)
                      }
                    }
                  }

                  const zipBlob = await zip.generateAsync({ type: 'blob' })
                  const url = URL.createObjectURL(zipBlob)
                  const link = document.createElement('a')
                  link.href = url
                  link.download = `cards-${statusFilter}-${new Date().toISOString().slice(0, 10)}.zip`
                  link.click()
                  URL.revokeObjectURL(url)
                }}
                disabled={!cardsQuery.data?.some((c) => c.renderKey)}
                className="cursor-pointer rounded-full border border-white/20 px-3 py-1 text-xs text-white disabled:cursor-not-allowed disabled:opacity-50"
              >
                Download All
              </button>
              <select
                value={statusFilter}
                onChange={(event) => setStatusFilter(event.target.value)}
                className="rounded-full border border-white/20 bg-slate-950/50 px-3 py-1 text-xs text-white"
              >
                <option value="draft">Draft</option>
                <option value="submitted">Submitted</option>
                <option value="rendered">Rendered</option>
              </select>
            </div>
          </div>
          {renderMutation.isError && (
            <p className="mt-2 text-xs text-rose-400">
              {renderMutation.error instanceof Error ? renderMutation.error.message : 'Render failed'}
            </p>
          )}
          <div className="mt-4 grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
            {cardsQuery.data?.map((card) => {
              const defaultTemplateId = resolveTemplateId(
                { cardType: card.cardType },
                activeConfig ?? undefined
              )
              const defaultTemplateLabel = templateLabelFor(defaultTemplateId)
              const hasUnknownTemplate =
                Boolean(card.templateId) &&
                !templateOptions.some((template) => template.id === card.templateId)
              const isRendering = renderingCardId === card.id

              return (
                <div key={card.id} className="rounded-2xl border border-white/10 bg-slate-950/60 p-3 text-xs text-slate-300">
                  <div className="space-y-1">
                    <div className="text-sm text-white">{card.cardType}</div>
                    <div>{card.id}</div>
                    <div>{cardDisplayName(card)}</div>
                  </div>

                  <label className="mt-3 block text-[11px] uppercase tracking-wide text-slate-400">
                    Template Override
                    <select
                      value={card.templateId ?? ''}
                      onChange={(event) =>
                        templateMutation.mutate({
                          id: card.id,
                          templateId: event.target.value ? event.target.value : null,
                        })
                      }
                      className="mt-2 w-full rounded-lg border border-white/10 bg-slate-950/60 px-2 py-1 text-xs text-white"
                    >
                      <option value="">{`Default (${defaultTemplateLabel})`}</option>
                      {hasUnknownTemplate ? (
                        <option value={card.templateId ?? ''}>{`Custom (${card.templateId})`}</option>
                      ) : null}
                      {templateOptions.map((template) => (
                        <option key={template.id} value={template.id}>
                          {template.label}
                        </option>
                      ))}
                    </select>
                  </label>

                  {card.renderKey ? (
                    <img
                      src={assetUrlForKey(card.renderKey)}
                      alt="Rendered card"
                      className="mt-3 w-full rounded-xl"
                    />
                  ) : (
                    <div className="mt-3 flex aspect-[825/1125] items-center justify-center rounded-xl border border-dashed border-white/10 text-[11px] text-slate-500">
                      No render
                    </div>
                  )}
                  <div className="mt-3 flex flex-wrap gap-2">
                    {card.status !== 'draft' ? (
                      <button
                        type="button"
                        onClick={() => renderMutation.mutate(card)}
                        disabled={isRendering || renderMutation.isPending}
                        className="rounded-full border border-emerald-500/40 px-3 py-1 text-[11px] text-emerald-300 disabled:cursor-not-allowed disabled:opacity-50"
                      >
                        {isRendering ? 'Rendering...' : 'Render'}
                      </button>
                    ) : null}
                    {card.status === 'draft' ? (
                      <button
                        type="button"
                        onClick={() => deleteMutation.mutate(card.id)}
                        className="rounded-full border border-rose-500/40 px-3 py-1 text-[11px] text-rose-300"
                      >
                        Delete Draft
                      </button>
                    ) : null}
                  </div>
                </div>
              )
            })}
          </div>
        </section>
      </div>
    </div>
  )
}
</file>

<file path="client/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { RouterProvider } from '@tanstack/react-router'
import * as Sentry from '@sentry/react'
import { router } from './router'
import './index.css'

const sentryDsn =
  import.meta.env.VITE_SENTRY_DSN ??
  'https://09af4582dc49164ae5df63813e981ebb@o4510562999664640.ingest.us.sentry.io/4510563001040896'

Sentry.init({
  dsn: sentryDsn,
  sendDefaultPii: false, // Don't send PII - users upload personal photos
  integrations: [
    Sentry.browserTracingIntegration(),
    Sentry.replayIntegration({
      // Block media to avoid recording user photos in replays
      blockAllMedia: true,
      // Mask all text inputs for privacy
      maskAllText: true,
    }),
  ],
  tracesSampleRate: 1.0,
  tracePropagationTargets: [
    'localhost',
    /^https:\/\/.*\.cloudfront\.net/,
    /^https:\/\/.*\.lambda-url\.us-east-1\.on\.aws/,
  ],
  replaysSessionSampleRate: import.meta.env.DEV ? 1.0 : 0.1,
  replaysOnErrorSampleRate: 1.0,
  enableLogs: true,
  environment: import.meta.env.MODE,
})

const queryClient = new QueryClient()

declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router
  }
}

const rootElement = document.getElementById('root')

if (!rootElement) {
  throw new Error('Root element not found')
}

createRoot(rootElement).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <RouterProvider router={router} />
    </QueryClientProvider>
  </StrictMode>
)
</file>

<file path="client/package.json">
{
  "name": "client",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "type-check": "tsc -b --pretty false",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@sentry/react": "^10.32.1",
    "@tailwindcss/vite": "^4.1.18",
    "@tanstack/react-query": "^5.90.12",
    "@tanstack/react-router": "^1.141.6",
    "@tanstack/react-router-devtools": "^1.141.6",
    "jszip": "^3.10.1",
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "react-easy-crop": "^5.5.6",
    "shared": "workspace:*",
    "tailwindcss": "^4.1.18"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.2",
    "@sentry/vite-plugin": "^4.6.1",
    "@types/node": "^22.19.2",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^4.7.0",
    "eslint": "^9.39.2",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.7.3",
    "typescript-eslint": "^8.49.0",
    "vite": "^6.4.1"
  }
}
</file>

<file path="client/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import { sentryVitePlugin } from "@sentry/vite-plugin";

const sentryAuthToken = process.env.SENTRY_AUTH_TOKEN;
const sentryPlugin = sentryAuthToken
	? sentryVitePlugin({
			org: "quadball",
			project: "javascript-react",
			authToken: sentryAuthToken,
			telemetry: false,
		})
	: null;

// Note: No proxy config needed - access via SST Router URL when running `sst dev`
// The Router handles /api/*, /u/*, and /r/* routing to Lambda and S3
export default defineConfig({
	plugins: [react(), tailwindcss(), ...(sentryPlugin ? [sentryPlugin] : [])],
	build: {
		sourcemap: Boolean(sentryAuthToken),
	},
});
</file>

<file path="shared/package.json">
{
  "name": "shared",
  "version": "0.0.1",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "type-check": "tsc -p tsconfig.json --noEmit",
    "lint": "eslint ."
  },
  "devDependencies": {
    "@eslint/js": "^9.39.2",
    "eslint": "^9.39.2",
    "globals": "^16.5.0",
    "typescript": "^5.9.3",
    "typescript-eslint": "^8.49.0"
  }
}
</file>

<file path="client/src/renderCard.ts">
import {
  CARD_HEIGHT,
  CARD_WIDTH,
  findTemplate,
  resolveTemplateId,
  type Card,
  type CropRect,
  type RenderMeta,
  type TemplateDefinition,
  type TemplateFlags,
  type TemplateTheme,
  type TournamentConfig,
} from 'shared'

const FONT_SANS = '"Sora", "Avenir Next", "Helvetica Neue", system-ui, sans-serif'
const FONT_DISPLAY = '"Fraunces", "Iowan Old Style", serif'

const BASE_THEME: TemplateTheme = {
  gradientStart: 'rgba(15, 23, 42, 0)',
  gradientEnd: 'rgba(15, 23, 42, 0.85)',
  border: 'rgba(255, 255, 255, 0.1)',
  accent: 'rgba(255, 255, 255, 0.5)',
  label: '#ffffff',
  nameColor: '#ffffff',
  meta: '#ffffff',
  watermark: 'rgba(255, 255, 255, 0.12)',
}

const FALLBACK_TEMPLATES: Record<string, TemplateDefinition> = {
  classic: {
    id: 'classic',
    label: 'Classic',
  },
  noir: {
    id: 'noir',
    label: 'Noir',
    theme: {
      gradientStart: 'rgba(10, 10, 15, 0)',
      gradientEnd: 'rgba(10, 10, 15, 0.92)',
      border: 'rgba(255, 255, 255, 0.18)',
      accent: 'rgba(255, 255, 255, 0.7)',
      label: '#ffffff',
      nameColor: '#ffffff',
      meta: '#ffffff',
      watermark: 'rgba(248, 250, 252, 0.2)',
    },
  },
}

const DEFAULT_TEMPLATE_FLAGS: TemplateFlags = {
  showGradient: true,
  showBorders: true,
  showWatermarkJersey: true,
}

const overlayCache = new Map<string, Promise<HTMLImageElement | null>>()

export type RenderCardInput = {
  card: Card
  config: TournamentConfig
  imageUrl: string
  resolveAssetUrl: (key: string) => string
  templateId?: string
}

export const resolveTemplateSnapshot = (input: {
  card: Card
  config: TournamentConfig
  templateId?: string
}): { templateId: string; templateSnapshot: RenderMeta['templateSnapshot'] } => {
  const effectiveTemplateId = resolveTemplateId(
    { templateId: input.templateId ?? input.card.templateId, cardType: input.card.cardType },
    input.config
  )
  const template =
    findTemplate(input.config, effectiveTemplateId) ??
    FALLBACK_TEMPLATES[effectiveTemplateId] ??
    FALLBACK_TEMPLATES.classic

  const theme = { ...BASE_THEME, ...(template.theme ?? {}) }
  const flags = { ...DEFAULT_TEMPLATE_FLAGS, ...(template.flags ?? {}) }
  const overlayPlacement = template.overlayPlacement ?? 'belowText'

  return {
    templateId: effectiveTemplateId,
    templateSnapshot: {
      overlayKey: template.overlayKey,
      theme,
      flags,
      overlayPlacement,
    },
  }
}

function loadImage(url: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const img = new Image()
    img.crossOrigin = 'anonymous'
    img.onload = () => resolve(img)
    img.onerror = () => reject(new Error('Failed to load image'))
    img.src = url
  })
}

async function loadImageSafe(url?: string | null) {
  if (!url) return null
  try {
    return await loadImage(url)
  } catch {
    return null
  }
}

async function loadOverlay(
  overlayKey: string | undefined,
  resolveAssetUrl: (key: string) => string
) {
  if (!overlayKey) return null
  const url = resolveAssetUrl(overlayKey)
  const cached = overlayCache.get(url)
  if (cached) return cached
  const promise = loadImage(url).catch(() => null)
  overlayCache.set(url, promise)
  return promise
}

function drawCroppedImage(
  ctx: CanvasRenderingContext2D,
  img: HTMLImageElement,
  crop: CropRect,
  destX: number,
  destY: number,
  destW: number,
  destH: number
) {
  const { x, y, w, h, rotateDeg } = crop

  const srcX = x * img.naturalWidth
  const srcY = y * img.naturalHeight
  const srcW = w * img.naturalWidth
  const srcH = h * img.naturalHeight

  ctx.save()

  const centerX = destX + destW / 2
  const centerY = destY + destH / 2
  ctx.translate(centerX, centerY)
  ctx.rotate((rotateDeg * Math.PI) / 180)
  ctx.translate(-centerX, -centerY)

  ctx.drawImage(img, srcX, srcY, srcW, srcH, destX, destY, destW, destH)

  ctx.restore()
}

function drawOutlinedText(
  ctx: CanvasRenderingContext2D,
  text: string,
  x: number,
  y: number,
  strokeWidth = 3
) {
  ctx.strokeStyle = 'black'
  ctx.lineWidth = strokeWidth
  ctx.lineJoin = 'round'
  ctx.strokeText(text, x, y)
  ctx.fillText(text, x, y)
}

function fillTextWithLetterSpacing(
  ctx: CanvasRenderingContext2D,
  text: string,
  x: number,
  y: number,
  spacingPx: number,
  strokeWidth = 2
) {
  ctx.strokeStyle = 'black'
  ctx.lineWidth = strokeWidth
  ctx.lineJoin = 'round'
  let cursor = x
  for (const ch of text) {
    ctx.strokeText(ch, cursor, y)
    ctx.fillText(ch, cursor, y)
    cursor += ctx.measureText(ch).width + spacingPx
  }
}

function fitText(
  ctx: CanvasRenderingContext2D,
  text: string,
  maxWidth: number,
  initialSize: number,
  minSize: number,
  fontFamily: string,
  fontWeight = 'bold'
) {
  let size = initialSize
  while (size > minSize) {
    ctx.font = `${fontWeight} ${size}px ${fontFamily}`
    if (ctx.measureText(text).width <= maxWidth) {
      return size
    }
    size -= 2
  }
  ctx.font = `${fontWeight} ${minSize}px ${fontFamily}`
  return minSize
}

function drawLogo(
  ctx: CanvasRenderingContext2D,
  img: HTMLImageElement,
  x: number,
  y: number,
  maxWidth: number,
  maxHeight: number
) {
  const ratio = Math.min(maxWidth / img.naturalWidth, maxHeight / img.naturalHeight, 1)
  const width = img.naturalWidth * ratio
  const height = img.naturalHeight * ratio
  ctx.drawImage(img, x, y, width, height)
}

function getTeamInfo(card: Card, config: TournamentConfig) {
  if ('teamId' in card && card.teamId) {
    const team = config.teams.find((entry) => entry.id === card.teamId)
    if (team) return team
  }
  if ('teamName' in card && card.teamName) {
    return { id: 'custom', name: card.teamName, logoKey: '' }
  }
  return null
}

function getCardTypeLabel(card: Card, config: TournamentConfig) {
  const entry = config.cardTypes.find((type) => type.type === card.cardType)
  return entry?.label ?? card.cardType
}

function getCardTypeConfig(card: Card, config: TournamentConfig) {
  return config.cardTypes.find((type) => type.type === card.cardType)
}

export async function renderCropBlob(input: { imageUrl: string; crop: CropRect }): Promise<Blob> {
  const { imageUrl, crop } = input
  const img = await loadImage(imageUrl)

  const srcW = crop.w * img.naturalWidth
  const srcH = crop.h * img.naturalHeight
  const canvas = document.createElement('canvas')
  canvas.width = Math.max(1, Math.round(srcW))
  canvas.height = Math.max(1, Math.round(srcH))
  const ctx = canvas.getContext('2d')

  if (!ctx) {
    throw new Error('Could not get canvas context')
  }

  drawCroppedImage(ctx, img, crop, 0, 0, canvas.width, canvas.height)

  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob) => {
        if (blob) resolve(blob)
        else reject(new Error('Failed to create blob'))
      },
      'image/png',
      1.0
    )
  })
}

export async function renderCard(input: RenderCardInput): Promise<Blob> {
  const { card, config, imageUrl, resolveAssetUrl, templateId } = input
  const { templateSnapshot } = resolveTemplateSnapshot({ card, config, templateId })
  const { theme, flags, overlayKey, overlayPlacement } = templateSnapshot

  if (document.fonts?.ready) {
    await document.fonts.ready
  }

  const canvas = document.createElement('canvas')
  canvas.width = CARD_WIDTH
  canvas.height = CARD_HEIGHT
  const ctx = canvas.getContext('2d')

  if (!ctx) {
    throw new Error('Could not get canvas context')
  }

  ctx.imageSmoothingEnabled = true
  ctx.imageSmoothingQuality = 'high'
  const img = await loadImage(imageUrl)
  const crop = card.photo?.crop ?? { x: 0, y: 0, w: 1, h: 1, rotateDeg: 0 }
  drawCroppedImage(ctx, img, crop, 0, 0, CARD_WIDTH, CARD_HEIGHT)

  if (flags.showGradient) {
    const overlayGradient = ctx.createLinearGradient(0, CARD_HEIGHT - 350, 0, CARD_HEIGHT)
    overlayGradient.addColorStop(0, theme.gradientStart)
    overlayGradient.addColorStop(1, theme.gradientEnd)
    ctx.fillStyle = overlayGradient
    ctx.fillRect(0, CARD_HEIGHT - 350, CARD_WIDTH, 350)
  }

  if (flags.showBorders) {
    ctx.strokeStyle = theme.border
    ctx.lineWidth = 2
    ctx.strokeRect(20, 20, CARD_WIDTH - 40, CARD_HEIGHT - 40)

    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)'
    ctx.lineWidth = 1
    ctx.strokeRect(30, 30, CARD_WIDTH - 60, CARD_HEIGHT - 60)
  }

  const overlayImg = await loadOverlay(overlayKey, resolveAssetUrl)
  if (overlayImg && overlayPlacement !== 'aboveText') {
    if (overlayImg.naturalWidth !== CARD_WIDTH || overlayImg.naturalHeight !== CARD_HEIGHT) {
      console.warn('Overlay is not 825x1125; scaling to fit.', overlayImg.naturalWidth, overlayImg.naturalHeight)
    }
    ctx.drawImage(overlayImg, 0, 0, CARD_WIDTH, CARD_HEIGHT)
  }

  const cardLabel = getCardTypeLabel(card, config).toUpperCase()
  ctx.font = `13px ${FONT_SANS}`
  ctx.fillStyle = theme.label
  ctx.textAlign = 'left'
  fillTextWithLetterSpacing(ctx, cardLabel, 50, 45, 2.5)

  const cardTypeConfig = getCardTypeConfig(card, config)
  const team = getTeamInfo(card, config)
  const logoKey =
    card.cardType === 'player' || card.cardType === 'team-staff'
      ? team?.logoKey
      : card.cardType === 'tournament-staff' || card.cardType === 'rare'
        ? config.branding.tournamentLogoKey
        : cardTypeConfig?.logoOverrideKey ?? config.branding.orgLogoKey

  const logoImg = await loadImageSafe(logoKey ? resolveAssetUrl(logoKey) : null)
  if (logoImg) {
    drawLogo(ctx, logoImg, CARD_WIDTH - 170, 40, 120, 80)
  }

  if (
    flags.showWatermarkJersey &&
    card.cardType !== 'rare' &&
    cardTypeConfig?.showJerseyNumber &&
    card.jerseyNumber
  ) {
    ctx.font = `bold 130px ${FONT_SANS}`
    ctx.fillStyle = theme.watermark
    ctx.textAlign = 'right'
    ctx.fillText(card.jerseyNumber, CARD_WIDTH - 50, 155)
  }

  if (card.cardType === 'rare') {
    const title = card.title ?? 'Rare Card'
    const caption = card.caption ?? ''

    ctx.strokeStyle = theme.accent
    ctx.lineWidth = 1
    ctx.beginPath()
    ctx.moveTo(120, CARD_HEIGHT / 2 - 40)
    ctx.lineTo(CARD_WIDTH - 120, CARD_HEIGHT / 2 - 40)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(120, CARD_HEIGHT / 2 + 40)
    ctx.lineTo(CARD_WIDTH - 120, CARD_HEIGHT / 2 + 40)
    ctx.stroke()

    const titleSize = fitText(ctx, title, CARD_WIDTH - 200, 52, 28, FONT_DISPLAY)
    ctx.font = `bold ${titleSize}px ${FONT_DISPLAY}`
    ctx.fillStyle = theme.nameColor
    ctx.textAlign = 'center'
    drawOutlinedText(ctx, title, CARD_WIDTH / 2, CARD_HEIGHT / 2 - 5, 4)

    if (caption) {
      ctx.font = `20px ${FONT_SANS}`
      ctx.fillStyle = theme.meta
      drawOutlinedText(ctx, caption, CARD_WIDTH / 2, CARD_HEIGHT / 2 + 30, 2)
    }
  } else {
    const fullName = [card.firstName, card.lastName].filter(Boolean).join(' ').trim()
    const nameText = fullName || 'Player Name'
    const nameFontSize = fitText(ctx, nameText, CARD_WIDTH - 100, 56, 34, FONT_DISPLAY)
    ctx.fillStyle = theme.nameColor
    ctx.textAlign = 'left'
    ctx.font = `bold ${nameFontSize}px ${FONT_DISPLAY}`
    drawOutlinedText(ctx, nameText, 50, CARD_HEIGHT - 180, 4)

    const positionTeam = [card.position, team?.name].filter(Boolean).join(' / ')
    ctx.font = `28px ${FONT_SANS}`
    ctx.fillStyle = theme.meta
    drawOutlinedText(ctx, positionTeam || 'Position / Team', 50, CARD_HEIGHT - 130, 2)

    if (cardTypeConfig?.showJerseyNumber && card.jerseyNumber) {
      ctx.font = `bold 36px ${FONT_SANS}`
      ctx.fillStyle = theme.meta
      drawOutlinedText(ctx, `#${card.jerseyNumber}`, 50, CARD_HEIGHT - 80, 3)
    }
  }

  if (card.photographer) {
    ctx.font = `18px ${FONT_SANS}`
    ctx.fillStyle = theme.label
    ctx.textAlign = 'right'
    drawOutlinedText(ctx, `Photo: ${card.photographer}`, CARD_WIDTH - 50, CARD_HEIGHT - 40, 2)
  }

  if (overlayImg && overlayPlacement === 'aboveText') {
    if (overlayImg.naturalWidth !== CARD_WIDTH || overlayImg.naturalHeight !== CARD_HEIGHT) {
      console.warn('Overlay is not 825x1125; scaling to fit.', overlayImg.naturalWidth, overlayImg.naturalHeight)
    }
    ctx.drawImage(overlayImg, 0, 0, CARD_WIDTH, CARD_HEIGHT)
  }

  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob) => {
        if (blob) {
          resolve(blob)
        } else {
          reject(new Error('Failed to create blob'))
        }
      },
      'image/png',
      1.0
    )
  })
}
</file>

<file path="server/package.json">
{
  "name": "server",
  "version": "0.0.1",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsx watch src/dev.ts",
    "type-check": "tsc -p tsconfig.json --noEmit",
    "lint": "eslint ."
  },
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3.955.0",
    "@aws-sdk/client-s3": "^3.955.0",
    "@aws-sdk/lib-dynamodb": "^3.955.0",
    "@aws-sdk/s3-presigned-post": "^3.955.0",
    "@aws-sdk/s3-request-presigner": "^3.955.0",
    "@hono/node-server": "^1.13.1",
    "hono": "^4.10.8",
    "jszip": "^3.10.1",
    "shared": "workspace:*",
    "sst": "3.17.25"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.2",
    "@types/node": "^22.19.2",
    "eslint": "^9.39.2",
    "globals": "^16.5.0",
    "tsx": "^4.20.5",
    "typescript-eslint": "^8.49.0"
  }
}
</file>

<file path="shared/src/types/index.ts">
export type ApiResponse = {
  message: string;
  success: boolean;
};

export type CardType =
  | "player"
  | "team-staff"
  | "media"
  | "official"
  | "tournament-staff"
  | "rare";

export type CardStatus = "draft" | "submitted" | "rendered";

export type TemplateTheme = {
  gradientStart: string;
  gradientEnd: string;
  border: string;
  accent: string;
  label: string;
  nameColor: string;
  meta: string;
  watermark: string;
};

export type TemplateFlags = {
  showGradient: boolean;
  showBorders: boolean;
  showWatermarkJersey: boolean;
};

export type TemplateDefinition = {
  id: string;
  label: string;
  overlayKey?: string;
  theme?: Partial<TemplateTheme>;
  flags?: Partial<TemplateFlags>;
  overlayPlacement?: "belowText" | "aboveText";
};

export type TemplateDefaults = {
  fallback: string;
  byCardType?: Partial<Record<CardType, string>>;
};

export type RenderMeta = {
  key: string;
  templateId: string;
  renderedAt: string;
  templateSnapshot: {
    overlayKey?: string;
    theme: TemplateTheme;
    flags: TemplateFlags;
    overlayPlacement: "belowText" | "aboveText";
  };
};

export type CropRect = {
  x: number;
  y: number;
  w: number;
  h: number;
  rotateDeg: 0 | 90 | 180 | 270;
};

export type CardPhoto = {
  originalKey?: string;
  width?: number;
  height?: number;
  crop?: CropRect;
  cropKey?: string;
};

export type CardBase = {
  id: string;
  editToken?: string;
  tournamentId: string;
  cardType: CardType;
  templateId?: string;
  status: CardStatus;
  photographer?: string;
  photo?: CardPhoto;
  renderKey?: string;
  renderMeta?: RenderMeta;
  createdAt: string;
  updatedAt: string;
  statusCreatedAt?: string;
};

export type StandardCard = CardBase & {
  cardType: Exclude<CardType, "rare">;
  firstName?: string;
  lastName?: string;
  teamId?: string;
  teamName?: string;
  position?: string;
  jerseyNumber?: string;
};

export type RareCard = CardBase & {
  cardType: "rare";
  title?: string;
  caption?: string;
};

export type Card = StandardCard | RareCard;

export type TournamentListEntry = {
  id: string;
  name: string;
  year: number;
  published?: boolean;
};

export type TournamentConfig = {
  id: string;
  name: string;
  year: number;
  branding: {
    tournamentLogoKey: string;
    orgLogoKey?: string;
    primaryColor?: string;
  };
  teams: Array<{
    id: string;
    name: string;
    logoKey: string;
  }>;
  cardTypes: Array<{
    type: CardType;
    enabled: boolean;
    label: string;
    showTeamField: boolean;
    showJerseyNumber: boolean;
    positions?: string[];
    logoOverrideKey?: string;
  }>;
  templates?: TemplateDefinition[];
  defaultTemplates?: TemplateDefaults;
  createdAt: string;
  updatedAt: string;
};

export type CardDesign = Card;
</file>

<file path="shared/src/index.ts">
export * from "./types"
export * from "./constants"
export * from "./tournaments"
export * from "./validation"
export * from "./templates"
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

A sports trading card creation app. Users upload photos, crop them via drag-and-drop, fill out player details (name, position, team, jersey number, photographer credit), and submit cards for rendering. Built as a monorepo with pnpm workspaces.

## Commands

```bash
# Install dependencies
pnpm install

# Development (two terminals required)
AWS_PROFILE=prod npx sst dev       # Terminal 1: SST infra + Lambda
cd client && pnpm dev              # Terminal 2: Vite frontend

# Build
pnpm build

# Type checking
pnpm type-check

# Linting
pnpm lint

# Deploy to AWS
AWS_PROFILE=prod npx sst deploy
```

## Pre-commit Hooks

Husky + lint-staged runs on every commit:
- `pnpm type-check` - Full monorepo type checking
- `eslint --fix` - Auto-fix lint issues on staged files

## Development Workflow

**Run in two terminals:**

Terminal 1 - SST (deploys infra, runs Lambda):
```bash
AWS_PROFILE=prod npx sst dev
```

Terminal 2 - Vite (frontend dev server):
```bash
cd client && pnpm dev
```

Access the app at `http://localhost:5173`.

**Environment variables:** `client/.env.development` contains `VITE_API_URL` and `VITE_ROUTER_URL`. Update these if SST outputs change (new stage, redeployed Lambda).

**URL routing:**
- **Production:** Same-origin via CloudFront Router (`/api/*`, `/r/*`, `/c/*`)
- **Dev:** Frontend calls Lambda URL directly (CORS enabled), media via Router

## Architecture

### Monorepo Structure

- **client/** - React 19 + Vite + TanStack Router + TailwindCSS v4
- **server/** - Hono API (runs locally via tsx, deploys as Lambda)
- **shared/** - TypeScript types shared between client and server

### Key Technologies

- **SST v3** for AWS infrastructure (DynamoDB, S3, Lambda, CloudFront Router)
- **TanStack Query** for client data fetching
- **react-easy-crop** for drag-and-drop image cropping

### SST Resources (sst.config.ts)

- `Cards` - DynamoDB table with GSI on status+createdAt
- `Media` - S3 bucket for uploads and renders
- `Api` - Lambda function running Hono
- `CardRouter` - CloudFront router with routes:
  - `/api/*` → Lambda API
  - `/r/*` → S3 renders
  - `/c/*` → S3 config

### API Routes (server/src/index.ts)

| Method | Path | Description |
|--------|------|-------------|
| POST | `/uploads/presign` | Get presigned URL for S3 upload |
| POST | `/cards` | Create new card draft |
| GET | `/cards/:id` | Get card by ID |
| PATCH | `/cards/:id` | Update card |
| POST | `/cards/:id/submit` | Submit card for rendering |

### Data Flow

1. Client creates card draft → gets card ID
2. Client uploads original photo using presigned URL
3. User crops image (stored as normalized percentages)
4. Client can upload cropped image
5. Submit triggers render pipeline (renderKey stored on card)

### Type Aliases (tsconfig.json)

```
@server/* → ./server/src/*
@client/* → ./client/src/*
@shared/* → ./shared/src/*
```

### Canvas Renderer (client/src/renderCard.ts)

Generates 825x1125 PNG cards client-side:
- Full-bleed image with gradient overlay
- Text overlays: name, position/team, jersey number, photo credit
- Uses shared constants from `shared/src/constants.ts`

## Development Notes

- Card status flow: `draft` → `submitted` → `rendered`
- Crop coordinates stored as normalized 0-1 floats (rotation disabled for v1)
- Card dimensions: 825x1125 pixels (constants in `shared/src/constants.ts`)
- Max upload size: 15MB, allowed types: JPEG, PNG, WebP (render must be PNG)
- S3 keys are versioned with unique upload IDs to avoid cache issues:
  - `uploads/original/<cardId>/<uploadId>.<ext>`
  - `uploads/crop/<cardId>/<uploadId>.<ext>`
  - `renders/<cardId>/<renderId>.png`
- Public PATCH cannot set `status` or `renderKey` (server-controlled fields)
- Presign endpoint requires card to exist (prevents orphan uploads)
- Submit endpoint requires valid renderKey and draft status

## Sentry

Client error tracking uses `@sentry/react` (initialized in `client/src/main.tsx`).

### Error / Exception Tracking

Use `Sentry.captureException(error)` in `catch` blocks or expected failure paths.

### Tracing

Create custom spans for meaningful user actions or API calls:

```javascript
Sentry.startSpan(
  { op: "ui.click", name: "Submit Card" },
  () => {
    // handler logic
  },
);
```

```javascript
async function fetchCards() {
  return Sentry.startSpan(
    { op: "http.client", name: "GET /api/cards" },
    async () => {
      const response = await fetch("/api/cards");
      return response.json();
    },
  );
}
```

### Logs

Import `* as Sentry` and use `const { logger } = Sentry` for structured logs.

```javascript
logger.info("Upload complete", { cardId });
logger.warn("Retrying upload", { attempt });
logger.error("Upload failed", { error: String(error) });
```
</file>

<file path="sst.config.ts">
/// <reference path="./.sst/platform/config.d.ts" />

export default $config({
  app(input) {
    return {
      name: "trading-card-app",
      removal: input?.stage === "production" ? "retain" : "remove",
      protect: ["production"].includes(input?.stage),
      home: "aws",
    };
  },
  async run() {
    const adminPassword = new sst.Secret("AdminPassword");
    const router = new sst.aws.Router("CardRouter");

    const mediaBucket = new sst.aws.Bucket("Media", {
      access: "cloudfront",
      cors: {
        allowHeaders: ["*"],
        allowMethods: ["GET", "HEAD", "POST", "PUT"],
        // Allow all origins for presigned uploads - bucket is private, URLs are short-lived
        allowOrigins: ["*"],
      },
    });

    new aws.s3.BucketLifecycleConfigurationV2("MediaUploadsLifecycle", {
      bucket: mediaBucket.name,
      rules: [
        {
          id: "expire-uploads",
          status: "Enabled",
          filter: {
            prefix: "uploads/",
          },
          expiration: {
            days: 14,
          },
        },
        {
          id: "expire-renders",
          status: "Enabled",
          filter: {
            prefix: "renders/",
          },
          expiration: {
            days: 365,
          },
        },
      ],
    });

    const cardsTable = new sst.aws.Dynamo("Cards", {
      fields: {
        id: "string",
        tournamentId: "string",
        status: "string",
        createdAt: "string",
        statusCreatedAt: "string",
      },
      primaryIndex: { hashKey: "id" },
      globalIndexes: {
        byStatus: { hashKey: "status", rangeKey: "createdAt" },
        byTournamentStatus: { hashKey: "tournamentId", rangeKey: "statusCreatedAt" },
      },
    });

    const api = new sst.aws.Function("Api", {
      handler: "server/src/lambda.handler",
      runtime: "nodejs20.x",
      url: {
        cors: {
          allowOrigins: ["*"],
          allowMethods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
          allowHeaders: ["Content-Type", "Authorization", "X-Edit-Token"],
        },
      },
      link: [mediaBucket, cardsTable, adminPassword],
    });

    router.route("/api", api.url, {
      rewrite: { regex: "^/api/(.*)$", to: "/$1" },
    });
    router.routeBucket("/r", mediaBucket, {
      rewrite: { regex: "^/r/(.*)$", to: "/renders/$1" },
    });
    router.routeBucket("/c", mediaBucket, {
      rewrite: { regex: "^/c/(.*)$", to: "/config/$1" },
    });

    const web = new sst.aws.StaticSite("Web", {
      path: "client",
      build: {
        command: "pnpm build",
        output: "dist",
      },
      environment: {
        VITE_API_URL: api.url,
        VITE_ROUTER_URL: router.url,
      },
      router: { instance: router },
    });

    return {
      web: web.url,
      api: api.url,
      router: router.url,
      media: mediaBucket.name,
      cards: cardsTable.name,
    };
  },
});
</file>

<file path="client/src/App.tsx">
import { useCallback, useEffect, useMemo, useRef, useState, type ChangeEvent, type DragEvent, type MouseEvent } from 'react'
import Cropper, { type Area, type MediaSize, type Point } from 'react-easy-crop'
import { useMutation, useQuery } from '@tanstack/react-query'
import {
  ALLOWED_UPLOAD_TYPES as ALLOWED_UPLOAD_TYPES_LIST,
  CARD_ASPECT,
  JERSEY_PATTERN,
  MAX_CAPTION_LENGTH,
  MAX_JERSEY_LENGTH,
  MAX_NAME_LENGTH,
  MAX_PHOTOGRAPHER_LENGTH,
  MAX_POSITION_LENGTH,
  MAX_TEAM_LENGTH,
  MAX_TITLE_LENGTH,
  MAX_UPLOAD_BYTES,
  resolveTemplateId,
  type ApiResponse,
  type Card,
  type CardType,
  type CropRect,
  type TournamentConfig,
  type TournamentListEntry,
  USQC_2025_CONFIG,
  USQC_2025_TOURNAMENT,
} from 'shared'
import { renderCard } from './renderCard'
import { api, assetUrlForKey, media, writeHeaders } from './api'
import { saveDraft, loadDraft, clearDraft, type SavedDraft } from './draftStorage'
import CropGuides from './components/CropGuides'

const ALLOWED_UPLOAD_TYPES: Set<string> = new Set(ALLOWED_UPLOAD_TYPES_LIST)
const MAX_UPLOAD_RETRIES = 1
const MAX_IMAGE_DIMENSION = 2600

type FormState = {
  tournamentId: string
  cardType: CardType | ''
  teamId: string
  position: string
  jerseyNumber: string
  firstName: string
  lastName: string
  title: string
  caption: string
  photographer: string
  templateId: string
}

type PhotoState = {
  file: File
  localUrl: string
  width: number
  height: number
}

type UploadedPhoto = {
  key: string
  publicUrl?: string
  width: number
  height: number
}

type SavePayload = {
  tournamentId?: string
  cardType?: CardType
  templateId?: string
  teamId?: string
  teamName?: string
  position?: string
  jerseyNumber?: string
  firstName?: string
  lastName?: string
  title?: string
  caption?: string
  photographer?: string
  photo?: {
    originalKey?: string
    width?: number
    height?: number
    crop?: CropRect
  }
}

type Rotation = CropRect['rotateDeg']

type PresignResponse = {
  uploadUrl: string
  key: string
  publicUrl?: string
  method: 'POST' | 'PUT'
  headers?: Record<string, string>
  fields?: Record<string, string>
}

type UploadProgress = {
  kind: 'original'
  percent: number
}

const initialForm: FormState = {
  tournamentId: '',
  cardType: '',
  teamId: '',
  position: '',
  jerseyNumber: '',
  firstName: '',
  lastName: '',
  title: '',
  caption: '',
  photographer: '',
  templateId: '',
}

const clamp = (value: number, min: number, max: number) =>
  Math.min(Math.max(value, min), max)

const toOptional = (value: string) => {
  const trimmed = value.trim()
  return trimmed.length > 0 ? trimmed : undefined
}

const buildDefaultCrop = (size: MediaSize, rotateDeg: Rotation): CropRect => {
  const imageAspect = size.naturalWidth / size.naturalHeight
  let w = 1
  let h = 1

  if (imageAspect > CARD_ASPECT) {
    w = CARD_ASPECT / imageAspect
  } else {
    h = imageAspect / CARD_ASPECT
  }

  const x = clamp((1 - w) / 2, 0, 1)
  const y = clamp((1 - h) / 2, 0, 1)

  return {
    x,
    y,
    w: clamp(w, 0.001, 1),
    h: clamp(h, 0.001, 1),
    rotateDeg,
  }
}

async function fetchHello(): Promise<ApiResponse> {
  const res = await fetch(api('/hello'))
  if (!res.ok) {
    throw new Error('API request failed')
  }
  return res.json()
}

async function fetchTournaments(): Promise<TournamentListEntry[]> {
  const res = await fetch(api('/tournaments'))
  if (!res.ok) {
    throw new Error('Could not load tournaments')
  }
  return res.json()
}

async function fetchTournamentConfig(id: string): Promise<TournamentConfig> {
  const res = await fetch(api(`/tournaments/${id}`))
  if (!res.ok) {
    throw new Error('Could not load tournament config')
  }
  return res.json()
}

const editHeadersFor = (editToken: string): HeadersInit => ({
  'Content-Type': 'application/json',
  ...writeHeaders,
  'X-Edit-Token': editToken,
})

async function createCard(payload: SavePayload): Promise<Card> {
  const res = await fetch(api('/cards'), {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...writeHeaders },
    body: JSON.stringify(payload),
  })

  if (!res.ok) {
    throw new Error('Could not create card')
  }

  return res.json()
}

async function updateCard(id: string, payload: SavePayload, editToken: string): Promise<Card> {
  const res = await fetch(api(`/cards/${id}`), {
    method: 'PATCH',
    headers: editHeadersFor(editToken),
    body: JSON.stringify(payload),
  })

  if (!res.ok) {
    throw new Error('Could not update card')
  }

  return res.json()
}

async function requestPresignFor(
  cardId: string,
  data: Blob,
  kind: 'original',
  editToken: string
): Promise<PresignResponse> {
  const res = await fetch(api('/uploads/presign'), {
    method: 'POST',
    headers: editHeadersFor(editToken),
    body: JSON.stringify({
      cardId,
      contentType: data.type,
      contentLength: data.size,
      kind,
    }),
  })

  if (!res.ok) {
    const error = await res.json().catch(() => ({}))
    throw new Error(error.error ?? 'Could not get upload URL')
  }

  return res.json()
}

const getUploadFilename = (key: string) => {
  const lastSegment = key.split('/').pop()
  return lastSegment && lastSegment.length > 0 ? lastSegment : 'upload'
}

const toUploadFile = (data: Blob, key: string) =>
  data instanceof File
    ? data
    : new File([data], getUploadFilename(key), {
        type: data.type || 'application/octet-stream',
      })

async function uploadToS3(
  presign: PresignResponse,
  data: Blob,
  onProgress?: (percent: number) => void
): Promise<void> {
  const uploadOnce = () =>
    new Promise<void>((resolve, reject) => {
      const xhr = new XMLHttpRequest()
      xhr.open(presign.method, presign.uploadUrl)

      if (presign.method !== 'POST' && presign.headers) {
        for (const [key, value] of Object.entries(presign.headers)) {
          xhr.setRequestHeader(key, value)
        }
      }

      if (xhr.upload && onProgress) {
        xhr.upload.onprogress = (event) => {
          const total = event.total || data.size
          if (!total) return
          const percent = Math.round((event.loaded / total) * 100)
          onProgress(Math.min(100, Math.max(0, percent)))
        }
      }

      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          onProgress?.(100)
          resolve()
        } else {
          reject(new Error('Upload failed'))
        }
      }
      xhr.onerror = () => reject(new Error('Upload failed'))
      xhr.onabort = () => reject(new Error('Upload aborted'))

      if (presign.method === 'POST') {
        if (!presign.fields) {
          reject(new Error('Upload fields are missing'))
          return
        }

        const formData = new FormData()
        for (const [key, value] of Object.entries(presign.fields)) {
          formData.append(key, value)
        }
        formData.append('file', toUploadFile(data, presign.key))
        xhr.send(formData)
        return
      }

      xhr.send(data)
    })

  let lastError: unknown = null
  for (let attempt = 0; attempt <= MAX_UPLOAD_RETRIES; attempt++) {
    try {
      await uploadOnce()
      return
    } catch (err) {
      lastError = err
      if (attempt < MAX_UPLOAD_RETRIES) {
        onProgress?.(0)
      }
    }
  }

  if (lastError instanceof Error) throw lastError
  throw new Error('Upload failed')
}

async function submitCard(id: string, editToken: string): Promise<Card> {
  const res = await fetch(api(`/cards/${id}/submit`), {
    method: 'POST',
    headers: editHeadersFor(editToken),
    body: JSON.stringify({}),
  })

  if (!res.ok) {
    throw new Error('Could not submit card')
  }

  return res.json()
}

function loadImageFromFile(file: File): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file)
    const img = new Image()

    img.onload = () => {
      URL.revokeObjectURL(url)
      resolve(img)
    }

    img.onerror = () => {
      URL.revokeObjectURL(url)
      reject(new Error('Failed to load image'))
    }

    img.src = url
  })
}

async function resizeImageIfNeeded(file: File): Promise<{ file: File; width: number; height: number }> {
  const img = await loadImageFromFile(file)
  const width = img.naturalWidth
  const height = img.naturalHeight
  const maxDim = Math.max(width, height)

  if (maxDim <= MAX_IMAGE_DIMENSION) {
    return { file, width, height }
  }

  const scale = MAX_IMAGE_DIMENSION / maxDim
  const targetWidth = Math.max(1, Math.round(width * scale))
  const targetHeight = Math.max(1, Math.round(height * scale))

  const canvas = document.createElement('canvas')
  canvas.width = targetWidth
  canvas.height = targetHeight
  const ctx = canvas.getContext('2d')
  if (!ctx) {
    return { file, width, height }
  }

  ctx.imageSmoothingEnabled = true
  ctx.imageSmoothingQuality = 'high'
  ctx.drawImage(img, 0, 0, targetWidth, targetHeight)

  const blob = await new Promise<Blob>((resolve, reject) => {
    canvas.toBlob(
      (result) => {
        if (result) resolve(result)
        else reject(new Error('Failed to resize image'))
      },
      file.type || 'image/jpeg',
      0.92
    )
  })

  const resizedFile = new File([blob], file.name, { type: blob.type })
  return { file: resizedFile, width: targetWidth, height: targetHeight }
}

function App() {
  const [form, setForm] = useState<FormState>(initialForm)
  const [selectedTournamentId, setSelectedTournamentId] = useState('')
  const [photo, setPhoto] = useState<PhotoState | null>(null)
  const fileInputRef = useRef<HTMLInputElement>(null)
  const [uploadedPhoto, setUploadedPhoto] = useState<UploadedPhoto | null>(null)
  const [mediaSize, setMediaSize] = useState<MediaSize | null>(null)
  const [crop, setCrop] = useState<Point>({ x: 0, y: 0 })
  const [zoom, setZoom] = useState(1)
  const [rotation, setRotation] = useState<Rotation>(0)
  const [normalizedCrop, setNormalizedCrop] = useState<CropRect | null>(null)
  const [showGuides, setShowGuides] = useState(true)
  const [cardId, setCardId] = useState<string | null>(null)
  const [editToken, setEditToken] = useState<string | null>(null)
  const [savedCard, setSavedCard] = useState<Card | null>(null)
  const [uploadStatus, setUploadStatus] = useState<'idle' | 'uploading' | 'uploaded' | 'error'>('idle')
  const [uploadProgress, setUploadProgress] = useState<UploadProgress | null>(null)
  const [error, setError] = useState<string | null>(null)
  const [photoError, setPhotoError] = useState<string | null>(null)
  const [renderedCardUrl, setRenderedCardUrl] = useState<string | null>(null)
  const [previewUrl, setPreviewUrl] = useState<string | null>(null)
  const [previewError, setPreviewError] = useState<string | null>(null)
  const [submitStatus, setSubmitStatus] = useState<'idle' | 'submitting' | 'done' | 'error'>('idle')
  const [hasEdited, setHasEdited] = useState(false)
  const [isDragging, setIsDragging] = useState(false)
  const [pendingDraft, setPendingDraft] = useState<SavedDraft | null>(null)

  const helloQuery = useQuery({
    queryKey: ['hello'],
    queryFn: fetchHello,
    enabled: false,
  })

  const tournamentsQuery = useQuery({
    queryKey: ['tournaments'],
    queryFn: fetchTournaments,
    initialData: [USQC_2025_TOURNAMENT],
  })

  useEffect(() => {
    if (!selectedTournamentId && tournamentsQuery.data.length > 0) {
      setSelectedTournamentId(tournamentsQuery.data[0].id)
    }
  }, [selectedTournamentId, tournamentsQuery.data])

  // Check for existing draft on mount
  useEffect(() => {
    const draft = loadDraft()
    if (draft) {
      setPendingDraft(draft)
    }
  }, [])

  const tournamentQuery = useQuery({
    queryKey: ['tournament', form.tournamentId],
    queryFn: () => fetchTournamentConfig(form.tournamentId),
    enabled: Boolean(form.tournamentId),
  })

  const tournamentConfig =
    tournamentQuery.data ??
    (form.tournamentId === USQC_2025_CONFIG.id ? USQC_2025_CONFIG : null)

  const cardTypeConfig = useMemo(
    () => tournamentConfig?.cardTypes.find((entry) => entry.type === form.cardType),
    [form.cardType, tournamentConfig]
  )
  const templateOptions = useMemo(() => {
    if (tournamentConfig?.templates && tournamentConfig.templates.length > 0) {
      return tournamentConfig.templates
    }
    return [
      { id: 'classic', label: 'Classic' },
      { id: 'noir', label: 'Noir' },
    ]
  }, [tournamentConfig])

  const defaultTemplateId = useMemo(
    () =>
      resolveTemplateId(
        {
          cardType: form.cardType || undefined,
        },
        tournamentConfig ?? undefined
      ),
    [form.cardType, tournamentConfig]
  )

  const defaultTemplateLabel = useMemo(
    () => templateOptions.find((template) => template.id === defaultTemplateId)?.label ?? defaultTemplateId,
    [defaultTemplateId, templateOptions]
  )

  const hasUnknownTemplate = Boolean(form.templateId) && !templateOptions.some((template) => template.id === form.templateId)

  const selectedTeam = useMemo(() => {
    if (!tournamentConfig) return null
    return tournamentConfig.teams.find((team) => team.id === form.teamId) ?? null
  }, [form.teamId, tournamentConfig])

  useEffect(() => {
    if (!cardTypeConfig?.positions || cardTypeConfig.positions.length === 0) return
    if (!form.position) return
    if (!cardTypeConfig.positions.includes(form.position)) {
      setForm((prev) => ({ ...prev, position: '' }))
    }
  }, [cardTypeConfig?.positions, form.position])

  const buildPayload = (): SavePayload => ({
    tournamentId: toOptional(form.tournamentId),
    cardType: form.cardType || undefined,
    templateId: form.templateId,
    teamId: toOptional(form.teamId),
    teamName: selectedTeam?.name,
    position: toOptional(form.position),
    jerseyNumber: toOptional(form.jerseyNumber),
    firstName: toOptional(form.firstName),
    lastName: toOptional(form.lastName),
    title: toOptional(form.title),
    caption: toOptional(form.caption),
    photographer: toOptional(form.photographer),
  })

  const buildUpdatePayload = (payload: SavePayload): SavePayload => {
    const rest = { ...payload }
    delete rest.tournamentId
    delete rest.cardType
    return rest
  }

  const buildPhotoPayload = (
    source: UploadedPhoto | null,
    cropValue: CropRect | null
  ): SavePayload['photo'] | undefined => {
    if (!source && !cropValue) return undefined

    const payload: SavePayload['photo'] = {}

    if (source) {
      payload.originalKey = source.key
      payload.width = source.width
      payload.height = source.height
    }

    if (cropValue) {
      payload.crop = cropValue
    }

    return payload
  }

  const ensureCard = async (payload: SavePayload) => {
    if (cardId && editToken) return { id: cardId, editToken }
    if (cardId && !editToken) {
      throw new Error('Edit token is missing. Please refresh and try again.')
    }

    if (!payload.tournamentId || !payload.cardType) {
      throw new Error('Select a tournament and card type before saving')
    }

    const card = await createCard(payload)
    if (!card.editToken) {
      throw new Error('Edit token is missing. Please refresh and try again.')
    }
    setCardId(card.id)
    setEditToken(card.editToken)
    setSavedCard(card)

    // Persist draft to localStorage for resume on refresh
    saveDraft({
      cardId: card.id,
      editToken: card.editToken,
      tournamentId: payload.tournamentId,
      cardType: payload.cardType,
      form: {
        teamId: form.teamId,
        position: form.position,
        jerseyNumber: form.jerseyNumber,
        firstName: form.firstName,
        lastName: form.lastName,
        title: form.title,
        caption: form.caption,
        photographer: form.photographer,
        templateId: form.templateId,
      },
      savedAt: new Date().toISOString(),
    })

    return { id: card.id, editToken: card.editToken }
  }

  const uploadOriginalPhoto = async (currentCardId: string, currentEditToken: string) => {
    if (!photo) {
      throw new Error('Please upload a photo before submitting')
    }

    setUploadStatus('uploading')
    setUploadProgress({ kind: 'original', percent: 0 })

    try {
      const presign = await requestPresignFor(currentCardId, photo.file, 'original', currentEditToken)
      await uploadToS3(presign, photo.file, (percent) =>
        setUploadProgress({ kind: 'original', percent })
      )

      const uploaded: UploadedPhoto = {
        key: presign.key,
        publicUrl: presign.publicUrl,
        width: photo.width,
        height: photo.height,
      }

      setUploadedPhoto(uploaded)
      setUploadStatus('uploaded')
      setUploadProgress(null)
      return uploaded
    } catch {
      setUploadStatus('error')
      setUploadProgress(null)
      throw new Error('Photo upload failed. Please try again.')
    }
  }

  const hasPhoto = Boolean(photo || uploadedPhoto)

  const getValidationErrors = useCallback(() => {
    const errors: Partial<Record<
      | 'tournamentId'
      | 'cardType'
      | 'firstName'
      | 'lastName'
      | 'teamId'
      | 'position'
      | 'title'
      | 'caption'
      | 'photo'
      | 'crop'
      | 'jerseyNumber',
      string
    >> = {}

    const firstName = form.firstName.trim()
    const lastName = form.lastName.trim()
    const position = form.position.trim()
    const jerseyNumber = form.jerseyNumber.trim()
    const title = form.title.trim()
    const caption = form.caption.trim()

    if (!form.tournamentId) {
      errors.tournamentId = 'Tournament is required'
    }

    if (!form.cardType) {
      errors.cardType = 'Card type is required'
    }

    if (form.cardType === 'rare') {
      if (!title) {
        errors.title = 'Title is required'
      } else if (title.length > MAX_TITLE_LENGTH) {
        errors.title = `Title must be ${MAX_TITLE_LENGTH} characters or fewer`
      }
      if (caption && caption.length > MAX_CAPTION_LENGTH) {
        errors.caption = `Caption must be ${MAX_CAPTION_LENGTH} characters or fewer`
      }
    } else {
      if (!firstName) {
        errors.firstName = 'First name is required'
      } else if (firstName.length > MAX_NAME_LENGTH) {
        errors.firstName = `First name must be ${MAX_NAME_LENGTH} characters or fewer`
      }

      if (!lastName) {
        errors.lastName = 'Last name is required'
      } else if (lastName.length > MAX_NAME_LENGTH) {
        errors.lastName = `Last name must be ${MAX_NAME_LENGTH} characters or fewer`
      }

      if (!position) {
        errors.position = 'Position is required'
      } else if (position.length > MAX_POSITION_LENGTH) {
        errors.position = `Position must be ${MAX_POSITION_LENGTH} characters or fewer`
      }

      if (cardTypeConfig?.showTeamField && !form.teamId) {
        errors.teamId = 'Team is required'
      }
    }

    if (form.teamId && selectedTeam?.name && selectedTeam.name.length > MAX_TEAM_LENGTH) {
      errors.teamId = `Team name must be ${MAX_TEAM_LENGTH} characters or fewer`
    }

    if (jerseyNumber && !JERSEY_PATTERN.test(jerseyNumber)) {
      errors.jerseyNumber = 'Jersey number must be 1-2 digits'
    }

    if (!hasPhoto) errors.photo = 'Photo is required'
    if (!normalizedCrop) errors.crop = 'Crop is required'

    return errors
  }, [
    form.caption,
    form.cardType,
    form.firstName,
    form.jerseyNumber,
    form.lastName,
    form.position,
    form.teamId,
    form.title,
    form.tournamentId,
    hasPhoto,
    normalizedCrop,
    cardTypeConfig,
    selectedTeam,
  ])

  const saveMutation = useMutation({
    mutationFn: async () => {
      setError(null)

      const payload = buildPayload()

      // Step 1: Create or get card ID
      const { id: currentCardId, editToken: currentEditToken } = await ensureCard(payload)

      // Step 2: Upload photo if we have a new one that hasn't been uploaded
      let photoPayload: SavePayload['photo'] = undefined

      if (photo && !uploadedPhoto) {
        const uploaded = await uploadOriginalPhoto(currentCardId, currentEditToken)
        photoPayload = buildPhotoPayload(uploaded, normalizedCrop)
      } else if (uploadedPhoto) {
        // Photo already uploaded, just update crop
        photoPayload = buildPhotoPayload(uploadedPhoto, normalizedCrop)
      } else if (normalizedCrop) {
        // Just crop, no photo
        photoPayload = buildPhotoPayload(null, normalizedCrop)
      }

      if (photoPayload) {
        payload.photo = photoPayload
      }

      // Step 3: Update card with all data
      const updatedCard = await updateCard(currentCardId, buildUpdatePayload(payload), currentEditToken)
      return updatedCard
    },
    onSuccess: (data) => {
      setSavedCard(data)
      if (data.editToken) setEditToken(data.editToken)

      // Update draft in localStorage with latest form data
      if (data.id && data.editToken && form.tournamentId && form.cardType) {
        saveDraft({
          cardId: data.id,
          editToken: data.editToken,
          tournamentId: form.tournamentId,
          cardType: form.cardType,
          form: {
            teamId: form.teamId,
            position: form.position,
            jerseyNumber: form.jerseyNumber,
            firstName: form.firstName,
            lastName: form.lastName,
            title: form.title,
            caption: form.caption,
            photographer: form.photographer,
            templateId: form.templateId,
          },
          savedAt: new Date().toISOString(),
        })
      }
    },
    onError: (err) => {
      setError(err instanceof Error ? err.message : 'Something went wrong')
    },
  })

  const submitMutation = useMutation({
    mutationFn: async () => {
      setHasEdited(true)

      const validationErrors = getValidationErrors()
      if (photoError || Object.keys(validationErrors).length > 0) {
        throw new Error('Please complete the required fields before submitting')
      }

      setError(null)

      if (!tournamentConfig) {
        throw new Error('Tournament config is not available')
      }

      const payload = buildPayload()
      const { id: currentCardId, editToken: currentEditToken } = await ensureCard(payload)
      const uploaded = uploadedPhoto ?? (photo ? await uploadOriginalPhoto(currentCardId, currentEditToken) : null)

      if (!uploaded) {
        throw new Error('Please upload a photo before submitting')
      }

      if (!normalizedCrop) {
        throw new Error('Please set a crop before submitting')
      }

      const photoPayload = buildPhotoPayload(uploaded, normalizedCrop)
      if (photoPayload) {
        payload.photo = photoPayload
      }

      await updateCard(currentCardId, buildUpdatePayload(payload), currentEditToken)

      // Submit the card
      setSubmitStatus('submitting')
      const submitted = await submitCard(currentCardId, currentEditToken)
      setSubmitStatus('done')

      return submitted
    },
    onSuccess: (data) => {
      setSavedCard(data)
      if (data.editToken) setEditToken(data.editToken)
      // Clear draft from localStorage after successful submit
      clearDraft()
    },
    onError: (err) => {
      setSubmitStatus('error')
      setError(err instanceof Error ? err.message : 'Submission failed')
    },
  })

  const validationErrors = useMemo(() => getValidationErrors(), [getValidationErrors])
  const canSubmit =
    !submitMutation.isPending &&
    !photoError &&
    Object.keys(validationErrors).length === 0 &&
    Boolean(tournamentConfig)

  const inputClass = (hasError: boolean) =>
    `mt-2 w-full rounded-xl border ${
      hasError ? 'border-rose-500/60' : 'border-white/10'
    } bg-slate-950/60 px-3 py-2 text-sm text-white`

  const statusIndicator = useMemo(() => {
    const errorMessage = error ?? (helloQuery.error instanceof Error ? helloQuery.error.message : null)
    if (errorMessage) return { message: errorMessage, tone: 'error' as const }

    if (submitStatus === 'submitting') return { message: 'Submitting card...', tone: 'warning' as const }
    if (submitStatus === 'done') return { message: 'Card submitted!', tone: 'success' as const }

    if (saveMutation.isPending) {
      if (uploadStatus === 'uploading') return { message: 'Uploading photo...', tone: 'warning' as const }
      return { message: 'Saving draft...', tone: 'warning' as const }
    }

    if (saveMutation.isSuccess) return { message: 'Draft saved', tone: 'success' as const }
    if (hasEdited && Object.keys(validationErrors).length > 0) {
      return { message: 'Complete required fields to submit.', tone: 'error' as const }
    }

    return { message: 'Draft not saved yet', tone: 'neutral' as const }
  }, [
    error,
    helloQuery.error,
    submitStatus,
    saveMutation.isPending,
    saveMutation.isSuccess,
    uploadStatus,
    hasEdited,
    validationErrors,
  ])

  const statusToneClass = {
    neutral: 'text-slate-400',
    warning: 'text-amber-400',
    success: 'text-emerald-400',
    error: 'text-rose-300',
  }[statusIndicator.tone]

  const saveButtonLabel = saveMutation.isPending
    ? uploadStatus === 'uploading'
      ? 'Uploading...'
      : 'Saving...'
    : 'Save Draft'

  const submitButtonLabel = submitMutation.isPending ? 'Submitting...' : 'Submit Card'

  const isSubmitInProgress = submitStatus === 'submitting'

  const handleFieldChange = (key: keyof FormState) =>
    (event: ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
      setHasEdited(true)
      setError(null)
      setForm((prev) => ({ ...prev, [key]: event.target.value }))
    }

  const handleCardTypeChange = (event: ChangeEvent<HTMLSelectElement>) => {
    const value = event.target.value as CardType | ''
    setHasEdited(true)
    setError(null)
    setForm((prev) => {
      const next = { ...prev, cardType: value }
      if (value === 'rare') {
        return {
          ...next,
          teamId: '',
          position: '',
          jerseyNumber: '',
          firstName: '',
          lastName: '',
        }
      }
      return {
        ...next,
        title: '',
        caption: '',
        teamId: value === 'player' || value === 'team-staff' ? next.teamId : '',
        jerseyNumber: value === 'player' ? next.jerseyNumber : '',
      }
    })
  }

  const handleResumeDraft = useCallback(() => {
    if (!pendingDraft) return

    // Restore card identifiers
    setCardId(pendingDraft.cardId)
    setEditToken(pendingDraft.editToken)

    // Restore form data
    setForm({
      tournamentId: pendingDraft.tournamentId,
      cardType: pendingDraft.cardType as CardType | '',
      ...pendingDraft.form,
    })
    setSelectedTournamentId(pendingDraft.tournamentId)

    // Close the modal
    setPendingDraft(null)
  }, [pendingDraft])

  const handleDismissDraft = useCallback(() => {
    clearDraft()
    setPendingDraft(null)
  }, [])

  const handleFileSelect = useCallback(async (file: File) => {
    setHasEdited(true)
    setError(null)

    if (!ALLOWED_UPLOAD_TYPES.has(file.type)) {
      setPhotoError('Unsupported file type. Use JPG, PNG, or WebP.')
      return
    }

    if (file.size > MAX_UPLOAD_BYTES) {
      setPhotoError('File is too large. Max size is 15MB.')
      return
    }

    setPhotoError(null)

    try {
      const resized = await resizeImageIfNeeded(file)
      const localUrl = URL.createObjectURL(resized.file)

      setPhoto((prev) => {
        if (prev) URL.revokeObjectURL(prev.localUrl)
        return {
          file: resized.file,
          localUrl,
          width: resized.width,
          height: resized.height,
        }
      })

      // Reset upload state when new photo is selected
      setUploadedPhoto(null)
      setUploadStatus('idle')
      setUploadProgress(null)
      setRenderedCardUrl(null)
      setPreviewUrl(null)
      setPreviewError(null)
      setSubmitStatus('idle')
      setMediaSize(null)

      // Reset crop
      setCrop({ x: 0, y: 0 })
      setZoom(1)
      setRotation(0)
      setNormalizedCrop(null)
    } catch {
      setError('Failed to load image')
    }
  }, [])

  const handleFileChange = useCallback((event: ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) return
    void handleFileSelect(file)
    event.target.value = ''
  }, [handleFileSelect])

  const handleUploadClick = useCallback((event: MouseEvent<HTMLElement>) => {
    event.preventDefault()
    fileInputRef.current?.click()
  }, [])

  const handleDrop = useCallback((event: DragEvent<HTMLElement>) => {
    event.preventDefault()
    setIsDragging(false)
    const file = event.dataTransfer.files?.[0]
    if (file) {
      void handleFileSelect(file)
    }
  }, [handleFileSelect])

  const handleDragOver = useCallback((event: DragEvent<HTMLElement>) => {
    event.preventDefault()
    if (!isDragging) {
      setIsDragging(true)
    }
  }, [isDragging])

  const handleDragLeave = useCallback(() => {
    setIsDragging(false)
  }, [])

  // react-easy-crop onCropComplete: (croppedArea, croppedAreaPixels)
  // 1st arg = percentages (0-100), 2nd arg = pixels
  const handleCropComplete = useCallback((croppedAreaPercent: Area) => {
    const clamp01 = (n: number) => Math.min(1, Math.max(0, n))
    setNormalizedCrop({
      x: clamp01(Number((croppedAreaPercent.x / 100).toFixed(4))),
      y: clamp01(Number((croppedAreaPercent.y / 100).toFixed(4))),
      w: clamp01(Number((croppedAreaPercent.width / 100).toFixed(4))),
      h: clamp01(Number((croppedAreaPercent.height / 100).toFixed(4))),
      rotateDeg: rotation,
    })
  }, [rotation])

  const handleMediaLoaded = useCallback((size: MediaSize) => {
    setMediaSize(size)
    setNormalizedCrop((prev) => prev ?? buildDefaultCrop(size, rotation))
  }, [rotation])

  const handleZoom = (delta: number) => {
    setZoom((prev) => clamp(Number((prev + delta).toFixed(2)), 1, 3))
  }

  const handleResetCrop = () => {
    setCrop({ x: 0, y: 0 })
    setZoom(1)
    setRotation(0)
    if (mediaSize) {
      setNormalizedCrop(buildDefaultCrop(mediaSize, 0))
    } else {
      setNormalizedCrop(null)
    }
  }

  const resetSession = useCallback(() => {
    setCardId(null)
    setEditToken(null)
    setSavedCard(null)
    setUploadedPhoto(null)
    setUploadStatus('idle')
    setUploadProgress(null)
    setRenderedCardUrl(null)
    setPreviewUrl(null)
    setPreviewError(null)
    setSubmitStatus('idle')
    setHasEdited(false)
    setError(null)
    setPhotoError(null)
    setNormalizedCrop(null)
    setMediaSize(null)
    setCrop({ x: 0, y: 0 })
    setZoom(1)
    setRotation(0)
    setPhoto((prev) => {
      if (prev) URL.revokeObjectURL(prev.localUrl)
      return null
    })
  }, [])

  const handleTournamentContinue = () => {
    if (!selectedTournamentId) return
    resetSession()
    setForm((prev) => ({
      ...initialForm,
      tournamentId: selectedTournamentId,
      templateId: prev.templateId,
    }))
  }

  const handleTournamentReset = () => {
    resetSession()
    setForm(initialForm)
  }

  const handleSaveDraft = () => {
    setHasEdited(true)
    saveMutation.mutate()
  }

  const displayName = useMemo(() => {
    if (form.cardType === 'rare') {
      const title = form.title.trim()
      return title.length > 0 ? title : 'Rare Card'
    }

    const first = form.firstName.trim()
    const last = form.lastName.trim()
    const full = [first, last].filter(Boolean).join(' ')
    return full.length > 0 ? full : 'Player Name'
  }, [form.cardType, form.firstName, form.lastName, form.title])

  // Use S3 URL if uploaded, otherwise local blob URL
  const uploadedCropperUrl = uploadedPhoto?.publicUrl ? media(uploadedPhoto.publicUrl) : null
  const cropperImageUrl = photo?.localUrl ?? uploadedCropperUrl

  const buildCardForRender = useCallback(
    (timestamp: string): Card | null => {
      if (!form.cardType || !form.tournamentId) return null

      return {
        id: cardId ?? 'preview',
        tournamentId: form.tournamentId,
        cardType: form.cardType as CardType,
        status: savedCard?.status ?? 'draft',
        createdAt: savedCard?.createdAt ?? timestamp,
        updatedAt: timestamp,
        templateId: toOptional(form.templateId),
        photographer: toOptional(form.photographer),
        photo: normalizedCrop ? { crop: normalizedCrop } : undefined,
        firstName: toOptional(form.firstName),
        lastName: toOptional(form.lastName),
        position: toOptional(form.position),
        teamId: toOptional(form.teamId),
        teamName: selectedTeam?.name,
        jerseyNumber: toOptional(form.jerseyNumber),
        title: toOptional(form.title),
        caption: toOptional(form.caption),
      }
    },
    [
      cardId,
      form.caption,
      form.cardType,
      form.firstName,
      form.jerseyNumber,
      form.lastName,
      form.photographer,
      form.position,
      form.teamId,
      form.templateId,
      form.title,
      form.tournamentId,
      normalizedCrop,
      savedCard?.createdAt,
      savedCard?.status,
      selectedTeam,
    ]
  )

  useEffect(() => {
    if (!tournamentConfig || !cropperImageUrl || !normalizedCrop || !form.cardType) {
      setPreviewUrl((prev) => {
        if (prev) URL.revokeObjectURL(prev)
        return null
      })
      setPreviewError(null)
      return
    }

    let cancelled = false
    const timeout = setTimeout(async () => {
      try {
        const timestamp = new Date().toISOString()
        const card = buildCardForRender(timestamp)
        if (!card) return
        const blob = await renderCard({
          card,
          config: tournamentConfig,
          imageUrl: cropperImageUrl,
          resolveAssetUrl: assetUrlForKey,
          templateId: toOptional(form.templateId),
        })
        if (cancelled) return
        const url = URL.createObjectURL(blob)
        setPreviewUrl((prev) => {
          if (prev) URL.revokeObjectURL(prev)
          return url
        })
        setPreviewError(null)
      } catch {
        if (!cancelled) {
          setPreviewError('Preview failed to render')
        }
      }
    }, 500)

    return () => {
      cancelled = true
      clearTimeout(timeout)
    }
  }, [buildCardForRender, cropperImageUrl, form.cardType, form.templateId, normalizedCrop, tournamentConfig])

  return (
    <div className="app-shell min-h-screen">
      {/* Resume Draft Modal */}
      {pendingDraft && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm">
          <div className="mx-4 w-full max-w-md rounded-2xl border border-white/10 bg-slate-900 p-6 shadow-xl">
            <h2 className="text-lg font-semibold text-white">Resume your draft?</h2>
            <p className="mt-2 text-sm text-slate-300">
              You have an unsaved draft from {new Date(pendingDraft.savedAt).toLocaleString()}.
              Would you like to continue where you left off?
            </p>
            <p className="mt-2 text-xs text-slate-400">
              Note: You&apos;ll need to re-upload your photo.
            </p>
            <div className="mt-6 flex gap-3">
              <button
                onClick={handleResumeDraft}
                className="flex-1 rounded-xl bg-indigo-600 px-4 py-2.5 text-sm font-medium text-white hover:bg-indigo-500"
              >
                Resume Draft
              </button>
              <button
                onClick={handleDismissDraft}
                className="flex-1 rounded-xl border border-white/10 bg-white/5 px-4 py-2.5 text-sm font-medium text-white hover:bg-white/10"
              >
                Start Fresh
              </button>
            </div>
          </div>
        </div>
      )}

      <div className="mx-auto flex max-w-6xl flex-col gap-10 px-6 py-12">
        <header className="flex flex-col gap-4">
          <p className="text-xs uppercase tracking-[0.3em] text-slate-400">
            Trading Card Studio
          </p>
          <div className="space-y-2">
            <h1 className="font-display text-4xl text-white md:text-5xl">
              Build and submit your trading card
            </h1>
            <p className="max-w-2xl text-base text-slate-300">
              Upload a photo, drag to frame the shot, and submit when it looks right.
              We save a draft automatically as part of submission.
            </p>
          </div>
        </header>

        {!form.tournamentId ? (
          <section className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
            <div className="flex flex-wrap items-center justify-between gap-4">
              <div>
                <h2 className="text-lg font-semibold text-white">Select a tournament</h2>
                <p className="text-sm text-slate-400">
                  Choose a tournament to load teams, positions, and branding.
                </p>
              </div>
              <span className="text-xs text-slate-400">
                {tournamentsQuery.isFetching ? 'Loading…' : `${tournamentsQuery.data.length} available`}
              </span>
            </div>
            <div className="mt-6 flex flex-col gap-4 sm:flex-row sm:items-end">
              <label className="flex-1 text-xs uppercase tracking-wide text-slate-400">
                Tournament
                <select
                  value={selectedTournamentId}
                  onChange={(event) => setSelectedTournamentId(event.target.value)}
                  className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                >
                  <option value="">Select tournament</option>
                  {tournamentsQuery.data.map((tournament) => (
                    <option key={tournament.id} value={tournament.id}>
                      {tournament.name} {tournament.year}
                    </option>
                  ))}
                </select>
              </label>
              <button
                type="button"
                onClick={handleTournamentContinue}
                disabled={!selectedTournamentId}
                className="rounded-full bg-emerald-500 px-6 py-2 text-xs font-semibold text-white transition hover:bg-emerald-400 disabled:cursor-not-allowed disabled:opacity-60"
              >
                Continue →
              </button>
            </div>
            <p className="mt-3 text-xs text-slate-500">
              Admins can publish new tournaments from the admin panel.
            </p>
          </section>
        ) : (
          <div className="grid gap-10 lg:grid-cols-[1.05fr_0.95fr]">
            <section className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
              <div className="flex flex-wrap items-center justify-between gap-4">
                <div>
                  <h2 className="text-lg font-semibold text-white">Card Details</h2>
                  <p className="text-sm text-slate-400">
                    Draft ID: {cardId ?? 'Auto-created on submit'}
                  </p>
                  <p className="text-xs text-slate-500">Fields marked * are required.</p>
                </div>
                <div className="flex items-center gap-3 text-xs text-slate-400">
                  <button
                    type="button"
                    onClick={() => helloQuery.refetch()}
                    className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
                  >
                    Ping API
                  </button>
                  <span>{helloQuery.data ? 'Connected' : 'Idle'}</span>
                </div>
              </div>

              <div className="mt-4 flex flex-wrap items-center justify-between gap-3 rounded-2xl border border-white/10 bg-slate-950/40 px-4 py-3 text-xs text-slate-300">
                <div>
                  <span className="uppercase tracking-[0.2em] text-slate-500">Tournament</span>
                  <div className="mt-1 text-sm text-white">
                    {tournamentConfig?.name ?? form.tournamentId}
                  </div>
                </div>
                <button
                  type="button"
                  onClick={handleTournamentReset}
                  className="rounded-full border border-white/20 px-3 py-1 text-[11px] text-white transition hover:border-white/40"
                >
                  Change
                </button>
              </div>
              {!tournamentConfig ? (
                <p className="mt-2 text-xs text-rose-300">
                  Tournament config failed to load. Refresh or reselect the tournament.
                </p>
              ) : null}

              <form
                className="mt-6 grid gap-4 sm:grid-cols-2"
                onSubmit={(event) => {
                  event.preventDefault()
                  setHasEdited(true)
                  if (canSubmit) submitMutation.mutate()
                }}
              >
                <label className="text-xs uppercase tracking-wide text-slate-400">
                  Card Type <span className="text-rose-400">*</span>
                  <select
                    value={form.cardType}
                    onChange={handleCardTypeChange}
                    disabled={!tournamentConfig}
                    className={inputClass(hasEdited && Boolean(validationErrors.cardType))}
                  >
                    <option value="">Select type</option>
                    {tournamentConfig?.cardTypes
                      .filter((entry) => entry.enabled)
                      .map((entry) => (
                        <option key={entry.type} value={entry.type}>
                          {entry.label}
                        </option>
                      ))}
                  </select>
                  {hasEdited && validationErrors.cardType ? (
                    <span className="mt-1 block text-[11px] text-rose-300">
                      {validationErrors.cardType}
                    </span>
                  ) : null}
                </label>

                <label className="text-xs uppercase tracking-wide text-slate-400">
                  Card Style
                  <select
                    value={form.templateId}
                    onChange={handleFieldChange('templateId')}
                    className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  >
                    <option value="">{`Default (${defaultTemplateLabel})`}</option>
                    {hasUnknownTemplate ? (
                      <option value={form.templateId}>{`Custom (${form.templateId})`}</option>
                    ) : null}
                    {templateOptions.map((template) => (
                      <option key={template.id} value={template.id}>
                        {template.label}
                      </option>
                    ))}
                  </select>
                </label>

                {form.cardType === 'rare' ? (
                  <>
                    <label className="text-xs uppercase tracking-wide text-slate-400 sm:col-span-2">
                      Title <span className="text-rose-400">*</span>
                      <input
                        value={form.title}
                        onChange={handleFieldChange('title')}
                        maxLength={MAX_TITLE_LENGTH}
                        className={inputClass(hasEdited && Boolean(validationErrors.title))}
                        placeholder="Championship MVP"
                      />
                      {hasEdited && validationErrors.title ? (
                        <span className="mt-1 block text-[11px] text-rose-300">
                          {validationErrors.title}
                        </span>
                      ) : null}
                    </label>
                    <label className="text-xs uppercase tracking-wide text-slate-400 sm:col-span-2">
                      Caption
                      <textarea
                        value={form.caption}
                        onChange={handleFieldChange('caption')}
                        maxLength={MAX_CAPTION_LENGTH}
                        rows={2}
                        className={inputClass(hasEdited && Boolean(validationErrors.caption))}
                        placeholder="Awarded to the tournament MVP"
                      />
                      {hasEdited && validationErrors.caption ? (
                        <span className="mt-1 block text-[11px] text-rose-300">
                          {validationErrors.caption}
                        </span>
                      ) : null}
                    </label>
                  </>
                ) : (
                  <>
                    {cardTypeConfig?.showTeamField ? (
                      <label className="text-xs uppercase tracking-wide text-slate-400">
                        Team <span className="text-rose-400">*</span>
                        <select
                          value={form.teamId}
                          onChange={handleFieldChange('teamId')}
                          className={inputClass(hasEdited && Boolean(validationErrors.teamId))}
                        >
                          <option value="">Select team</option>
                          {tournamentConfig?.teams.map((team) => (
                            <option key={team.id} value={team.id}>
                              {team.name}
                            </option>
                          ))}
                        </select>
                        {hasEdited && validationErrors.teamId ? (
                          <span className="mt-1 block text-[11px] text-rose-300">
                            {validationErrors.teamId}
                          </span>
                        ) : null}
                        {selectedTeam?.logoKey ? (
                          <img
                            src={assetUrlForKey(selectedTeam.logoKey)}
                            alt={`${selectedTeam.name} logo`}
                            className="mt-2 h-10 w-10 rounded-lg border border-white/10 object-contain"
                          />
                        ) : null}
                      </label>
                    ) : null}

                    <label className="text-xs uppercase tracking-wide text-slate-400">
                      Position <span className="text-rose-400">*</span>
                      {cardTypeConfig?.positions && cardTypeConfig.positions.length > 0 ? (
                        <select
                          value={form.position}
                          onChange={handleFieldChange('position')}
                          className={inputClass(hasEdited && Boolean(validationErrors.position))}
                        >
                          <option value="">Select position</option>
                          {cardTypeConfig.positions.map((option) => (
                            <option key={option} value={option}>
                              {option}
                            </option>
                          ))}
                        </select>
                      ) : (
                        <input
                          value={form.position}
                          onChange={handleFieldChange('position')}
                          maxLength={MAX_POSITION_LENGTH}
                          className={inputClass(hasEdited && Boolean(validationErrors.position))}
                          placeholder="Keeper"
                        />
                      )}
                      {hasEdited && validationErrors.position ? (
                        <span className="mt-1 block text-[11px] text-rose-300">
                          {validationErrors.position}
                        </span>
                      ) : null}
                    </label>

                    {cardTypeConfig?.showJerseyNumber ? (
                      <label className="text-xs uppercase tracking-wide text-slate-400">
                        Jersey Number
                        <input
                          value={form.jerseyNumber}
                          onChange={handleFieldChange('jerseyNumber')}
                          maxLength={MAX_JERSEY_LENGTH}
                          inputMode="numeric"
                          pattern="\\d*"
                          className={inputClass(hasEdited && Boolean(validationErrors.jerseyNumber))}
                          placeholder="15"
                        />
                        {hasEdited && validationErrors.jerseyNumber ? (
                          <span className="mt-1 block text-[11px] text-rose-300">
                            {validationErrors.jerseyNumber}
                          </span>
                        ) : (
                          <span className="mt-1 block text-[11px] text-slate-500">
                            Numbers only, up to 2 digits.
                          </span>
                        )}
                      </label>
                    ) : null}

                    <label className="text-xs uppercase tracking-wide text-slate-400">
                      First Name <span className="text-rose-400">*</span>
                      <input
                        value={form.firstName}
                        onChange={handleFieldChange('firstName')}
                        maxLength={MAX_NAME_LENGTH}
                        className={inputClass(hasEdited && Boolean(validationErrors.firstName))}
                        placeholder="Brandon"
                      />
                      {hasEdited && validationErrors.firstName ? (
                        <span className="mt-1 block text-[11px] text-rose-300">
                          {validationErrors.firstName}
                        </span>
                      ) : null}
                    </label>

                    <label className="text-xs uppercase tracking-wide text-slate-400">
                      Last Name <span className="text-rose-400">*</span>
                      <input
                        value={form.lastName}
                        onChange={handleFieldChange('lastName')}
                        maxLength={MAX_NAME_LENGTH}
                        className={inputClass(hasEdited && Boolean(validationErrors.lastName))}
                        placeholder="Williams"
                      />
                      {hasEdited && validationErrors.lastName ? (
                        <span className="mt-1 block text-[11px] text-rose-300">
                          {validationErrors.lastName}
                        </span>
                      ) : null}
                    </label>
                  </>
                )}

                <label className="text-xs uppercase tracking-wide text-slate-400 sm:col-span-2">
                  Photo Credit
                  <input
                    value={form.photographer}
                    onChange={handleFieldChange('photographer')}
                    maxLength={MAX_PHOTOGRAPHER_LENGTH}
                    className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                    placeholder="Paul Schiopu"
                  />
                </label>
              </form>

              <div className="mt-6">
                <label className="text-xs uppercase tracking-wide text-slate-400">
                  Card Photo <span className="text-rose-400">*</span>
                </label>
                <label
                  className={`mt-3 flex cursor-pointer flex-col items-center justify-center gap-2 rounded-2xl border border-dashed px-6 py-8 text-center text-sm text-slate-300 transition ${
                    isDragging ? 'border-emerald-400/70 bg-emerald-500/10' : 'border-white/15 bg-slate-950/40'
                  }`}
                  onClick={handleUploadClick}
                  onDrop={handleDrop}
                  onDragOver={handleDragOver}
                  onDragLeave={handleDragLeave}
                >
                  <input
                    type="file"
                    accept="image/jpeg,image/png,image/webp"
                    className="sr-only"
                    onChange={handleFileChange}
                    ref={fileInputRef}
                  />
                  <div className="flex items-center gap-2 text-xs uppercase tracking-[0.3em] text-slate-400">
                    Drop photo here
                  </div>
                  <p className="text-xs text-slate-500">
                    or click to upload (JPG, PNG, WebP · max 15MB)
                  </p>
                  {photo ? (
                    <p className="text-xs text-emerald-300">
                      {photo.file.name} · {photo.width} x {photo.height} px
                    </p>
                  ) : (
                    <p className="text-xs text-slate-500">Auto-resized to {MAX_IMAGE_DIMENSION}px max</p>
                  )}
                </label>
                <div className="mt-2 flex flex-wrap items-center gap-3 text-xs text-slate-400">
                  <span>{photo ? photo.file.name : 'No file selected'}</span>
                  {uploadedPhoto && <span className="text-emerald-400">Uploaded</span>}
                </div>
                {photoError ? (
                  <p className="mt-2 text-xs text-rose-300">{photoError}</p>
                ) : hasEdited && validationErrors.photo ? (
                  <p className="mt-2 text-xs text-rose-300">{validationErrors.photo}</p>
                ) : null}
              </div>

              <div className="mt-6 flex flex-wrap items-center gap-4">
                <button
                  type="button"
                  onClick={handleSaveDraft}
                  disabled={saveMutation.isPending}
                  className="rounded-full bg-white px-5 py-2 text-xs font-semibold text-slate-900 transition hover:bg-slate-100 disabled:cursor-not-allowed disabled:opacity-70"
                >
                  {saveButtonLabel}
                </button>
                <button
                  type="button"
                  onClick={() => submitMutation.mutate()}
                  disabled={!canSubmit}
                  className="rounded-full bg-emerald-500 px-5 py-2 text-xs font-semibold text-white transition hover:bg-emerald-400 disabled:cursor-not-allowed disabled:opacity-50"
                >
                  {submitButtonLabel}
                </button>
                <span className="text-xs text-slate-500">
                  Submit saves a draft automatically.
                </span>
                <div className="flex flex-wrap items-center gap-3 text-xs">
                  <span className={statusToneClass}>{statusIndicator.message}</span>
                  {uploadProgress ? (
                    <div className="flex items-center gap-2">
                      <div
                        className="h-1 w-24 overflow-hidden rounded-full bg-white/10"
                        role="progressbar"
                        aria-valuemin={0}
                        aria-valuemax={100}
                        aria-valuenow={uploadProgress.percent}
                      >
                        <div
                          className="h-full rounded-full bg-emerald-400 transition-all"
                          style={{ width: `${uploadProgress.percent}%` }}
                        />
                      </div>
                      <span className="text-[11px] text-slate-400">
                        Photo{' '}
                        {uploadProgress.percent}%
                      </span>
                    </div>
                  ) : null}
                </div>
              </div>
            </section>

            <section className="space-y-6">
              <div
                className={`rounded-3xl border border-emerald-500/30 bg-emerald-950/20 p-6 backdrop-blur ${
                  submitStatus === 'done' ? 'celebrate' : ''
                }`}
              >
                <div className="flex items-center justify-between gap-3">
                  <h3 className="text-sm uppercase tracking-[0.2em] text-emerald-400">
                    {renderedCardUrl ? 'Rendered Card' : 'Live Preview'}
                  </h3>
                  {previewUrl && !renderedCardUrl ? (
                    <span className="text-xs text-emerald-200/70">Updating preview</span>
                  ) : null}
                </div>
                {renderedCardUrl ? (
                  <>
                    <div className="mt-4">
                      <img
                        src={renderedCardUrl}
                        alt="Rendered trading card"
                        className="w-full rounded-2xl shadow-lg"
                      />
                    </div>
                    <div className="mt-4 flex flex-wrap items-center gap-3">
                      <a
                        href={renderedCardUrl}
                        download="trading-card.png"
                        className="rounded-full border border-emerald-500/30 px-4 py-2 text-xs text-emerald-400 transition hover:border-emerald-500/60 hover:bg-emerald-500/10"
                      >
                        Download PNG
                      </a>
                      <span className="text-xs text-slate-400">
                        Status: {savedCard?.status ?? 'unknown'}
                      </span>
                    </div>
                  </>
                ) : previewUrl ? (
                  <div className="mt-4">
                    <img
                      src={previewUrl}
                      alt="Live preview trading card"
                      className="w-full rounded-2xl shadow-lg"
                    />
                    <p className="mt-2 text-xs text-slate-400">
                      Preview updates as you edit. Submit to send for rendering.
                    </p>
                  </div>
                ) : (
                  <div className="mt-4">
                    <div className="flex aspect-[825/1125] w-full items-center justify-center rounded-2xl border border-dashed border-emerald-500/30 bg-slate-950/50 text-xs text-emerald-200/70">
                      {isSubmitInProgress ? (
                        <div className="flex flex-col items-center gap-3 text-emerald-200/70">
                          <div className="h-10 w-10 animate-spin rounded-full border border-emerald-400/40 border-t-transparent" />
                          <span className="text-[11px] uppercase tracking-[0.2em]">
                            Submitting card
                          </span>
                        </div>
                      ) : previewError ? (
                        previewError
                      ) : (
                        'Upload a photo and crop to see the live preview.'
                      )}
                    </div>
                  </div>
                )}
              </div>

              <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
                <div>
                  <h2 className="text-lg font-semibold text-white">Live Crop</h2>
                  <p className="text-sm text-slate-400">
                    Drag the image to frame it. Scroll or pinch to zoom.
                  </p>
                </div>

                <div className="mt-5">
                  <div className="relative aspect-[825/1125] w-full overflow-hidden rounded-[28px] border border-white/10 bg-slate-950/60 shadow-[0_20px_60px_rgba(3,7,18,0.6)]">
                    {cropperImageUrl ? (
                      <Cropper
                        image={cropperImageUrl}
                        crop={crop}
                        zoom={zoom}
                        rotation={0}
                        aspect={CARD_ASPECT}
                        onCropChange={setCrop}
                        onZoomChange={setZoom}
                        onCropComplete={handleCropComplete}
                        onMediaLoaded={handleMediaLoaded}
                        showGrid={false}
                        classes={{
                          containerClassName: 'cropper-container',
                          cropAreaClassName: 'cropper-area',
                        }}
                      />
                    ) : (
                      <div className="flex h-full w-full items-center justify-center text-sm text-slate-400">
                        Upload a photo to start cropping
                      </div>
                    )}
                    <CropGuides visible={showGuides} />
                  </div>
                  {hasEdited && validationErrors.crop ? (
                    <p className="mt-2 text-xs text-rose-300">{validationErrors.crop}</p>
                  ) : null}
                </div>

                <div className="mt-5 flex flex-wrap items-center gap-3">
                  <button
                    type="button"
                    onClick={() => handleZoom(0.2)}
                    className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
                  >
                    Zoom In
                  </button>
                  <button
                    type="button"
                    onClick={() => handleZoom(-0.2)}
                    className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
                  >
                    Zoom Out
                  </button>
                  <button
                    type="button"
                    onClick={handleResetCrop}
                    className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
                  >
                    Reset
                  </button>
                  <button
                    type="button"
                    onClick={() => setShowGuides((prev) => !prev)}
                    className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
                  >
                    {showGuides ? 'Hide Guides' : 'Show Guides'}
                  </button>
                </div>
              </div>

              <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
                <h3 className="text-sm uppercase tracking-[0.2em] text-slate-400">
                  Preview Meta
                </h3>
                <div className="mt-4 space-y-3">
                  <div className="font-display text-2xl text-white">{displayName}</div>
                  <div className="text-sm text-slate-300">
                    {form.cardType === 'rare'
                      ? form.caption || 'Caption'
                      : [form.position || 'Position', selectedTeam?.name || (cardTypeConfig?.showTeamField ? 'Team' : '')]
                          .filter(Boolean)
                          .join(' / ')}
                  </div>
                  <div className="text-xs text-slate-400">
                    Crop: {normalizedCrop ? `${normalizedCrop.w.toFixed(2)} x ${normalizedCrop.h.toFixed(2)}` : '-'}
                  </div>
                  {uploadedPhoto && (
                    <div className="text-xs text-slate-400">
                      Photo: <span className="text-emerald-400">{uploadedPhoto.key}</span>
                    </div>
                  )}
                  {savedCard ? (
                    <div className="rounded-2xl border border-white/10 bg-slate-950/60 px-4 py-3 text-xs text-slate-300">
                      Saved as <span className="text-white">{savedCard.id}</span>
                    </div>
                  ) : null}
                </div>
              </div>
            </section>
          </div>
        )}
      </div>
    </div>
  )
}

export default App
</file>

<file path="server/src/index.ts">
import { Hono, type MiddlewareHandler } from 'hono'
import { Resource } from 'sst'
import { randomUUID } from 'node:crypto'
import { Readable } from 'node:stream'
import { text as streamToText } from 'node:stream/consumers'
import JSZip from 'jszip'
import { createPresignedPost } from '@aws-sdk/s3-presigned-post'
import { getSignedUrl } from '@aws-sdk/s3-request-presigner'
import { GetObjectCommand, HeadObjectCommand, PutObjectCommand, S3Client } from '@aws-sdk/client-s3'
import { ConditionalCheckFailedException, DynamoDBClient } from '@aws-sdk/client-dynamodb'
import { DynamoDBDocumentClient, GetCommand, PutCommand, QueryCommand, UpdateCommand, DeleteCommand } from '@aws-sdk/lib-dynamodb'
import type { ApiResponse, Card, CardStatus, CardType, CropRect, RenderMeta, TournamentConfig, TournamentListEntry } from 'shared'
import {
  ALLOWED_RENDER_TYPES as ALLOWED_RENDER_TYPES_LIST,
  ALLOWED_UPLOAD_TYPES as ALLOWED_UPLOAD_TYPES_LIST,
  JERSEY_PATTERN,
  MAX_CAPTION_LENGTH,
  MAX_NAME_LENGTH,
  MAX_PHOTOGRAPHER_LENGTH,
  MAX_POSITION_LENGTH,
  MAX_TEAM_LENGTH,
  MAX_TITLE_LENGTH,
  MAX_UPLOAD_BYTES,
  USQC_2025_CONFIG,
  USQC_2025_TOURNAMENT,
} from 'shared'

const app = new Hono()

// Note: CORS is handled by Lambda Function URL configuration, not Hono middleware

const RATE_LIMIT_WINDOW_MS = 60_000
const RATE_LIMIT_MAX = 180
const rateLimitMap = new Map<string, { count: number; resetAt: number }>()
const adminAuthFailures = new Map<string, { count: number; resetAt: number }>()

const getClientIp = (c: { req: { header: (name: string) => string | undefined } }) =>
  c.req.header('x-forwarded-for')?.split(',')[0]?.trim() ||
  c.req.header('cf-connecting-ip') ||
  c.req.header('x-real-ip') ||
  'unknown'

const shouldRateLimit = (method: string) =>
  method === 'POST' || method === 'PUT' || method === 'PATCH' || method === 'DELETE'

const s3 = new S3Client({})
const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}))

const ALLOWED_UPLOAD_TYPES: Set<string> = new Set(ALLOWED_UPLOAD_TYPES_LIST)
const ALLOWED_RENDER_TYPES: Set<string> = new Set(ALLOWED_RENDER_TYPES_LIST)
const RENDER_EXTENSION = 'png'
const CONFIG_LIST_KEY = 'config/tournaments.json'
const CONFIG_PREFIX = 'config/tournaments'

const MAX_TEMPLATE_LENGTH = 32
const EDIT_TOKEN_HEADER = 'x-edit-token'
const ADMIN_AUTH_WINDOW_MS = 10 * 60_000
const ADMIN_AUTH_MAX_FAILURES = 24

const CARD_TYPES: CardType[] = [
  'player',
  'team-staff',
  'media',
  'official',
  'tournament-staff',
  'rare',
]

type PresignKind = 'original' | 'crop' | 'render'

type PresignRequest = {
  cardId: string
  contentType: string
  contentLength: number
  kind: PresignKind
}

type CardInput = Partial<Card> & {
  firstName?: string
  lastName?: string
  title?: string
  caption?: string
  teamId?: string
  teamName?: string
  position?: string
  jerseyNumber?: string
  templateId?: string
}

const isRecord = (value: unknown): value is Record<string, unknown> =>
  typeof value === 'object' && value !== null && !Array.isArray(value)

const nowIso = () => new Date().toISOString()

const isCardStatus = (value: unknown): value is CardStatus =>
  value === 'draft' || value === 'submitted' || value === 'rendered'

// Validate IDs used in S3 paths to prevent path traversal and URL issues
const SAFE_ID_PATTERN = /^[a-z0-9-]{3,64}$/
const isSafeId = (value: unknown): value is string =>
  typeof value === 'string' && SAFE_ID_PATTERN.test(value)

const isCardType = (value: unknown): value is CardType =>
  typeof value === 'string' && CARD_TYPES.includes(value as CardType)

const toNumber = (value: unknown): number | undefined => {
  if (typeof value === 'number' && Number.isFinite(value)) {
    return value
  }

  if (typeof value === 'string' && value.trim() !== '') {
    const parsed = Number(value)
    return Number.isFinite(parsed) ? parsed : undefined
  }

  return undefined
}

const toRotateDeg = (value: unknown): CropRect['rotateDeg'] | undefined => {
  const numeric = toNumber(value)

  if (numeric === 0 || numeric === 90 || numeric === 180 || numeric === 270) {
    return numeric
  }

  return undefined
}

const clamp = (n: number, min: number, max: number) => Math.min(Math.max(n, min), max)

const normalizeString = (value: unknown) => {
  if (typeof value !== 'string') return undefined
  const trimmed = value.trim()
  return trimmed.length > 0 ? trimmed : undefined
}

const ensureMaxLength = (value: string, max: number, label: string) => {
  if (value.length > max) {
    return `${label} must be ${max} characters or fewer`
  }
  return null
}

const buildStatusCreatedAt = (status: CardStatus, createdAt: string) => `${status}#${createdAt}`

const pickCrop = (value: unknown): CropRect | undefined => {
  if (!isRecord(value)) return undefined

  const rawX = toNumber(value.x)
  const rawY = toNumber(value.y)
  const rawW = toNumber(value.w)
  const rawH = toNumber(value.h)

  if (rawX === undefined || rawY === undefined || rawW === undefined || rawH === undefined) {
    return undefined
  }

  // Clamp values to valid ranges
  // x, y: 0 to 1
  // w, h: > 0 to 1
  const x = clamp(rawX, 0, 1)
  const y = clamp(rawY, 0, 1)
  const w = clamp(rawW, 0.001, 1) // minimum 0.1% width
  const h = clamp(rawH, 0.001, 1) // minimum 0.1% height

  // Ensure crop doesn't extend beyond image bounds
  const clampedW = Math.min(w, 1 - x)
  const clampedH = Math.min(h, 1 - y)

  const rotateDeg = toRotateDeg(value.rotateDeg) ?? 0

  return { x, y, w: clampedW, h: clampedH, rotateDeg }
}

const pickPhoto = (value: unknown): Card['photo'] | undefined => {
  if (!isRecord(value)) return undefined

  const photo: Card['photo'] = {}

  const originalKey = normalizeString(value.originalKey)
  const cropKey = normalizeString(value.cropKey)
  if (originalKey) photo.originalKey = originalKey
  if (cropKey) photo.cropKey = cropKey

  const width = toNumber(value.width)
  const height = toNumber(value.height)

  if (width !== undefined) photo.width = width
  if (height !== undefined) photo.height = height

  const crop = pickCrop(value.crop)
  if (crop) photo.crop = crop

  return Object.keys(photo).length > 0 ? photo : undefined
}

const isValidDimension = (value: unknown): value is number =>
  typeof value === 'number' && Number.isFinite(value) && value > 0

const isValidCropRect = (crop?: CropRect) => {
  if (!crop) return false

  const { x, y, w, h, rotateDeg } = crop

  if (![x, y, w, h].every((value) => typeof value === 'number' && Number.isFinite(value))) {
    return false
  }

  const rotateOk = rotateDeg === 0 || rotateDeg === 90 || rotateDeg === 180 || rotateDeg === 270
  if (!rotateOk) return false

  if (x < 0 || y < 0 || x > 1 || y > 1) return false
  if (w <= 0 || h <= 0 || w > 1 || h > 1) return false
  if (x + w > 1 || y + h > 1) return false

  return true
}

const validatePhotoKeys = (cardId: string, photo?: Card['photo']) => {
  if (!photo) return null

  if (photo.originalKey && !photo.originalKey.startsWith(`uploads/original/${cardId}/`)) {
    return 'originalKey must belong to this card'
  }

  if (photo.cropKey && !photo.cropKey.startsWith(`uploads/crop/${cardId}/`)) {
    return 'cropKey must belong to this card'
  }

  return null
}

const TEMPLATE_THEME_KEYS = [
  'gradientStart',
  'gradientEnd',
  'border',
  'accent',
  'label',
  'nameColor',
  'meta',
  'watermark',
] as const

const TEMPLATE_FLAG_KEYS = [
  'showGradient',
  'showBorders',
  'showWatermarkJersey',
] as const

const parseRenderMeta = (value: unknown, renderKey: string): RenderMeta | string => {
  if (!isRecord(value)) return 'renderMeta must be an object'

  const templateId = normalizeString(value.templateId)
  if (!templateId) return 'renderMeta.templateId is required'

  const renderedAt = normalizeString(value.renderedAt)
  if (!renderedAt) return 'renderMeta.renderedAt is required'

  const key = normalizeString(value.key) ?? renderKey
  if (key !== renderKey) return 'renderMeta.key must match renderKey'

  if (!isRecord(value.templateSnapshot)) return 'renderMeta.templateSnapshot is required'
  const snapshot = value.templateSnapshot

  const overlayKey = normalizeString(snapshot.overlayKey)

  if (!isRecord(snapshot.theme)) return 'renderMeta.templateSnapshot.theme is required'
  const themeSource = snapshot.theme
  const theme = {} as RenderMeta['templateSnapshot']['theme']
  for (const field of TEMPLATE_THEME_KEYS) {
    const raw = normalizeString(themeSource[field])
    if (!raw) return `renderMeta.templateSnapshot.theme.${field} is required`
    theme[field] = raw
  }

  if (!isRecord(snapshot.flags)) return 'renderMeta.templateSnapshot.flags is required'
  const flagsSource = snapshot.flags
  const flags = {} as RenderMeta['templateSnapshot']['flags']
  for (const field of TEMPLATE_FLAG_KEYS) {
    const raw = flagsSource[field]
    if (typeof raw !== 'boolean') {
      return `renderMeta.templateSnapshot.flags.${field} must be a boolean`
    }
    flags[field] = raw
  }

  const overlayPlacement = normalizeString(snapshot.overlayPlacement)
  if (overlayPlacement !== 'belowText' && overlayPlacement !== 'aboveText') {
    return 'renderMeta.templateSnapshot.overlayPlacement is invalid'
  }

  return {
    key,
    templateId,
    renderedAt,
    templateSnapshot: {
      overlayKey: overlayKey ?? undefined,
      theme,
      flags,
      overlayPlacement,
    },
  }
}

const validateCardFields = (card: CardInput) => {
  if (card.firstName) {
    const error = ensureMaxLength(card.firstName, MAX_NAME_LENGTH, 'firstName')
    if (error) return error
  }
  if (card.lastName) {
    const error = ensureMaxLength(card.lastName, MAX_NAME_LENGTH, 'lastName')
    if (error) return error
  }
  if (card.title) {
    const error = ensureMaxLength(card.title, MAX_TITLE_LENGTH, 'title')
    if (error) return error
  }
  if (card.caption) {
    const error = ensureMaxLength(card.caption, MAX_CAPTION_LENGTH, 'caption')
    if (error) return error
  }
  if (card.photographer) {
    const error = ensureMaxLength(card.photographer, MAX_PHOTOGRAPHER_LENGTH, 'photographer')
    if (error) return error
  }
  if (card.teamName) {
    const error = ensureMaxLength(card.teamName, MAX_TEAM_LENGTH, 'teamName')
    if (error) return error
  }
  if (card.teamId) {
    const error = ensureMaxLength(card.teamId, MAX_TEAM_LENGTH, 'teamId')
    if (error) return error
  }
  if (card.position) {
    const error = ensureMaxLength(card.position, MAX_POSITION_LENGTH, 'position')
    if (error) return error
  }
  if (card.templateId) {
    const error = ensureMaxLength(card.templateId, MAX_TEMPLATE_LENGTH, 'templateId')
    if (error) return error
  }
  if (card.jerseyNumber && !JERSEY_PATTERN.test(card.jerseyNumber)) {
    return 'jerseyNumber must be 1-2 digits'
  }

  return null
}

const getSubmitValidationError = (card: Card) => {
  if (!card.tournamentId) return 'tournamentId is required before submitting'
  if (!card.cardType || !isCardType(card.cardType)) {
    return 'cardType is required before submitting'
  }

  const fieldError = validateCardFields(card)
  if (fieldError) return fieldError

  const photo = card.photo
  if (!photo) return 'photo is required before submitting'
  if (!photo.originalKey) return 'photo.originalKey is required before submitting'
  if (!isValidDimension(photo.width) || !isValidDimension(photo.height)) {
    return 'photo dimensions are required before submitting'
  }
  if (!isValidCropRect(photo.crop)) return 'photo.crop is required before submitting'

  switch (card.cardType) {
    case 'rare':
      if (!card.title) return 'title is required before submitting'
      break
    default:
      if (!card.firstName) return 'firstName is required before submitting'
      if (!card.lastName) return 'lastName is required before submitting'
      if (!card.position) return 'position is required before submitting'
      break
  }

  if (card.cardType === 'player' || card.cardType === 'team-staff') {
    if (!card.teamId && !card.teamName) {
      return 'team is required before submitting'
    }
  }

  return null
}

const pickCardInput = (
  input: Record<string, unknown>,
  options?: { allowStatus?: boolean }
): CardInput => {
  const data: CardInput = {}

  const cardType = normalizeString(input.cardType) ?? normalizeString(input.type)
  if (cardType && isCardType(cardType)) data.cardType = cardType
  const tournamentId = normalizeString(input.tournamentId)
  if (tournamentId) data.tournamentId = tournamentId
  const templateId = normalizeString(input.templateId)
  if (templateId) data.templateId = templateId

  const teamId = normalizeString(input.teamId)
  if (teamId) data.teamId = teamId
  const teamName = normalizeString(input.teamName)
  if (teamName) data.teamName = teamName
  const position = normalizeString(input.position)
  if (position) data.position = position
  const jerseyNumber = normalizeString(input.jerseyNumber)
  if (jerseyNumber) data.jerseyNumber = jerseyNumber
  const firstName = normalizeString(input.firstName)
  if (firstName) data.firstName = firstName
  const lastName = normalizeString(input.lastName)
  if (lastName) data.lastName = lastName
  const photographer = normalizeString(input.photographer)
  if (photographer) data.photographer = photographer
  const title = normalizeString(input.title)
  if (title) data.title = title
  const caption = normalizeString(input.caption)
  if (caption) data.caption = caption

  const photo = pickPhoto(input.photo)
  if (photo) data.photo = photo

  if (options?.allowStatus && isCardStatus(input.status)) {
    data.status = input.status
  }

  return data
}

const getExtension = (contentType: string) => {
  switch (contentType) {
    case 'image/jpeg':
      return 'jpg'
    case 'image/png':
      return 'png'
    case 'image/webp':
      return 'webp'
    default:
      return null
  }
}

const getUploadKey = (cardId: string, kind: PresignKind, contentType: string) => {
  const uploadId = randomUUID().slice(0, 8)

  if (kind === 'render') {
    return `renders/${cardId}/${uploadId}.${RENDER_EXTENSION}`
  }

  const ext = getExtension(contentType)
  if (!ext) return null

  const prefix = kind === 'original' ? 'uploads/original' : 'uploads/crop'
  return `${prefix}/${cardId}/${uploadId}.${ext}`
}

const getPublicPath = (key: string) => {
  if (key.startsWith('renders/')) {
    return `/r/${key.slice('renders/'.length)}`
  }

  if (key.startsWith('config/')) {
    return `/c/${key.slice('config/'.length)}`
  }

  return null
}

const toPublicCard = (card: Card) => {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { photo, editToken, ...rest } = card

  if (!photo?.crop) {
    return rest
  }

  return {
    ...rest,
    photo: {
      crop: photo.crop,
    },
  }
}

const getJsonBody = async (c: { req: { json: () => Promise<unknown> } }) => {
  try {
    return await c.req.json()
  } catch {
    return null
  }
}

const badRequest = (c: { json: (data: unknown, status?: number) => Response }, message: string) =>
  c.json({ error: message }, 400)

const bodyToString = async (body: unknown) => {
  if (!body) return ''
  if (typeof body === 'string') return body
  if (body instanceof Uint8Array) return Buffer.from(body).toString('utf8')
  if (body instanceof ArrayBuffer) return Buffer.from(new Uint8Array(body)).toString('utf8')
  if (ArrayBuffer.isView(body)) return Buffer.from(body.buffer).toString('utf8')
  if (body && typeof (body as { transformToString?: () => Promise<string> }).transformToString === 'function') {
    return (body as { transformToString: () => Promise<string> }).transformToString()
  }
  if (body instanceof Readable) {
    return streamToText(body)
  }
  return ''
}

const readJsonFromS3 = async <T>(key: string): Promise<T | null> => {
  try {
    const result = await s3.send(
      new GetObjectCommand({
        Bucket: Resource.Media.name,
        Key: key,
      })
    )
    const text = await bodyToString(result.Body)
    return text ? (JSON.parse(text) as T) : null
  } catch (err) {
    const name = isRecord(err) ? String(err.name ?? '') : ''
    if (name === 'NoSuchKey' || name === 'NotFound') return null
    throw err
  }
}

const writeJsonToS3 = async (key: string, value: unknown, options?: { cacheControl?: string }) => {
  await s3.send(
    new PutObjectCommand({
      Bucket: Resource.Media.name,
      Key: key,
      Body: JSON.stringify(value, null, 2),
      ContentType: 'application/json',
      CacheControl: options?.cacheControl ?? 'no-store',
    })
  )
}

const getConfigKey = (tournamentId: string, stage: 'draft' | 'published') =>
  `${CONFIG_PREFIX}/${tournamentId}/${stage}/config.json`

type UpdateDraft = {
  set: Record<string, unknown>
  remove: string[]
}

const pushSet = (draft: UpdateDraft, path: string, value: unknown) => {
  draft.set[path] = value
  draft.remove = draft.remove.filter((entry) => entry !== path)
}

const pushRemove = (draft: UpdateDraft, path: string) => {
  if (!draft.remove.includes(path)) {
    draft.remove.push(path)
  }
  delete draft.set[path]
}

const applyStringUpdate = (
  draft: UpdateDraft,
  value: unknown,
  path: string,
  maxLength: number,
  label: string
) => {
  if (value === undefined) return null
  if (value === null) {
    pushRemove(draft, path)
    return null
  }
  if (typeof value !== 'string') return `${label} must be a string`
  const trimmed = value.trim()
  if (!trimmed) {
    pushRemove(draft, path)
    return null
  }
  const error = ensureMaxLength(trimmed, maxLength, label)
  if (error) return error
  pushSet(draft, path, trimmed)
  return null
}

app.use('*', async (c, next) => {
  if (shouldRateLimit(c.req.method) || c.req.path.startsWith('/admin/')) {
    const ip = getClientIp(c)
    const now = Date.now()
    const entry = rateLimitMap.get(ip)
    if (!entry || now > entry.resetAt) {
      rateLimitMap.set(ip, { count: 1, resetAt: now + RATE_LIMIT_WINDOW_MS })
    } else {
      entry.count += 1
      if (entry.count > RATE_LIMIT_MAX) {
        return c.json({ error: 'Too many requests' }, 429)
      }
    }
  }

  await next()
})

// Admin auth middleware - requires Bearer token matching AdminPassword secret
const requireAdmin: MiddlewareHandler = async (c, next) => {
  const auth = c.req.header('Authorization')
  const expected = `Bearer ${Resource.AdminPassword.value}`
  const ip = getClientIp(c)
  const now = Date.now()
  const failure = adminAuthFailures.get(ip)

  if (failure && now <= failure.resetAt && failure.count > ADMIN_AUTH_MAX_FAILURES) {
    return c.json({ error: 'Too many attempts' }, 429)
  }

  if (auth !== expected) {
    const entry = adminAuthFailures.get(ip)
    if (!entry || now > entry.resetAt) {
      adminAuthFailures.set(ip, { count: 1, resetAt: now + ADMIN_AUTH_WINDOW_MS })
    } else {
      entry.count += 1
      if (entry.count > ADMIN_AUTH_MAX_FAILURES) {
        return c.json({ error: 'Too many attempts' }, 429)
      }
    }
    return c.json({ error: 'Unauthorized' }, 401)
  }

  adminAuthFailures.delete(ip)
  await next()
}

// Protect all admin routes
app.use('/admin/*', requireAdmin)

const FALLBACK_TOURNAMENTS: TournamentListEntry[] = [USQC_2025_TOURNAMENT]
const FALLBACK_CONFIGS: Record<string, TournamentConfig> = {
  [USQC_2025_CONFIG.id]: USQC_2025_CONFIG,
}

app.get('/', (c) => c.text('Hello Hono!'))

app.get('/hello', (c) => {
  const data: ApiResponse = {
    message: 'Hello BHVR!',
    success: true,
  }

  return c.json(data, 200)
})

app.get('/tournaments', async (c) => {
  const list = (await readJsonFromS3<TournamentListEntry[]>(CONFIG_LIST_KEY)) ?? FALLBACK_TOURNAMENTS
  // Only return published tournaments to public
  return c.json(list.filter((t) => t.published))
})

app.get('/tournaments/:id', async (c) => {
  const id = c.req.param('id')
  const config =
    (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))) ??
    FALLBACK_CONFIGS[id]

  if (!config) {
    return c.json({ error: 'Tournament not found' }, 404)
  }

  return c.json(config)
})

app.get('/tournaments/:id/teams', async (c) => {
  const id = c.req.param('id')
  const config =
    (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))) ??
    FALLBACK_CONFIGS[id]

  if (!config) {
    return c.json({ error: 'Tournament not found' }, 404)
  }

  return c.json(config.teams)
})

app.get('/admin/tournaments', async (c) => {
  const list = (await readJsonFromS3<TournamentListEntry[]>(CONFIG_LIST_KEY)) ?? FALLBACK_TOURNAMENTS
  return c.json(list)
})

app.get('/admin/tournaments/:id', async (c) => {
  const id = c.req.param('id')
  const draft = await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'draft'))
  if (draft) return c.json(draft)

  const published = await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))
  if (published) return c.json(published)

  const fallback = FALLBACK_CONFIGS[id]
  if (fallback) return c.json(fallback)

  return c.json({ error: 'Tournament not found' }, 404)
})

app.post('/admin/tournaments', async (c) => {
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const id = normalizeString(body.id)
  const name = normalizeString(body.name)
  const year = toNumber(body.year)

  if (!id) return badRequest(c, 'id is required')
  if (!isSafeId(id)) return badRequest(c, 'id must be 3-64 lowercase alphanumeric characters or hyphens')
  if (!name) return badRequest(c, 'name is required')
  if (!year || year < 2000) return badRequest(c, 'year is required')

  const now = nowIso()
  const baseConfig = JSON.parse(JSON.stringify(USQC_2025_CONFIG)) as TournamentConfig
  baseConfig.id = id
  baseConfig.name = name
  baseConfig.year = Math.floor(year)
  baseConfig.branding = {
    tournamentLogoKey: `config/tournaments/${id}/logos/tournament.png`,
    orgLogoKey: `config/tournaments/${id}/logos/org.png`,
    primaryColor: baseConfig.branding.primaryColor,
  }
  baseConfig.teams = []
  baseConfig.createdAt = now
  baseConfig.updatedAt = now

  await writeJsonToS3(getConfigKey(id, 'draft'), baseConfig)

  const list = (await readJsonFromS3<TournamentListEntry[]>(CONFIG_LIST_KEY)) ?? FALLBACK_TOURNAMENTS
  const nextList = list.filter((entry) => entry.id !== id)
  nextList.push({ id, name, year: Math.floor(year), published: false })
  await writeJsonToS3(CONFIG_LIST_KEY, nextList, { cacheControl: 'public, max-age=60' })

  return c.json(baseConfig, 201)
})

app.put('/admin/tournaments/:id', async (c) => {
  const id = c.req.param('id')
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const now = nowIso()
  const config = body as TournamentConfig
  if (!config.name || !config.year) {
    return badRequest(c, 'name and year are required')
  }

  const existingConfig =
    (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'draft'))) ??
    (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))) ??
    FALLBACK_CONFIGS[id] ??
    null
  const existingTeamIds = new Set(existingConfig?.teams?.map((team) => team.id) ?? [])

  // Validate team IDs to prevent path traversal in S3 keys
  for (const team of config.teams ?? []) {
    if (!isSafeId(team.id)) {
      if (!existingTeamIds.has(team.id)) {
        return badRequest(
          c,
          `Team id "${team.id}" must be 3-64 lowercase alphanumeric characters or hyphens`
        )
      }
    }
  }

  config.id = id
  config.updatedAt = now
  config.createdAt = config.createdAt ?? now

  await writeJsonToS3(getConfigKey(id, 'draft'), config)

  return c.json(config)
})

// Team logos ZIP upload - upload multiple team logos at once
// ZIP structure: team-id.png files at root level
app.post('/admin/tournaments/:id/logos-zip', async (c) => {
  const id = c.req.param('id')

  const draft =
    (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'draft'))) ??
    (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))) ??
    FALLBACK_CONFIGS[id]

  if (!draft) {
    return c.json({ error: 'Tournament not found' }, 404)
  }

  const arrayBuffer = await c.req.arrayBuffer()
  if (arrayBuffer.byteLength === 0) {
    return badRequest(c, 'Empty request body')
  }

  let zip: JSZip
  try {
    zip = await JSZip.loadAsync(arrayBuffer)
  } catch {
    return badRequest(c, 'Invalid ZIP file')
  }

  const teamIds = new Set(draft.teams.map((t) => t.id))
  const results: {
    uploaded: string[]
    skipped: Array<{ filename: string; reason: string }>
    missingLogos: string[]
  } = {
    uploaded: [],
    skipped: [],
    missingLogos: [],
  }

  const uploadPromises: Promise<void>[] = []

  zip.forEach((relativePath, file) => {
    // Skip directories and hidden files
    if (file.dir || relativePath.startsWith('__MACOSX') || relativePath.startsWith('.')) {
      return
    }

    // Get just the filename (handle nested paths)
    const filename = relativePath.split('/').pop() ?? relativePath
    if (!filename.toLowerCase().endsWith('.png')) {
      results.skipped.push({ filename, reason: 'Not a PNG file' })
      return
    }

    const teamId = filename.slice(0, -4) // Remove .png
    if (!teamIds.has(teamId)) {
      results.skipped.push({ filename, reason: `No team with ID "${teamId}" in config` })
      return
    }

    uploadPromises.push(
      (async () => {
        const data = await file.async('nodebuffer')
        const key = `config/tournaments/${id}/teams/${teamId}.png`
        await s3.send(
          new PutObjectCommand({
            Bucket: Resource.Media.name,
            Key: key,
            Body: data,
            ContentType: 'image/png',
          })
        )
        results.uploaded.push(teamId)
      })()
    )
  })

  await Promise.all(uploadPromises)

  // Find teams still missing logos
  const uploadedSet = new Set(results.uploaded)
  for (const team of draft.teams) {
    if (!uploadedSet.has(team.id)) {
      // Check if logo already exists in S3
      try {
        await s3.send(
          new HeadObjectCommand({
            Bucket: Resource.Media.name,
            Key: `config/tournaments/${id}/teams/${team.id}.png`,
          })
        )
      } catch {
        results.missingLogos.push(team.id)
      }
    }
  }

  return c.json(results)
})

app.post('/admin/tournaments/:id/assets/presign', async (c) => {
  const id = c.req.param('id')
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const kind = normalizeString(body.kind)
  const contentType = normalizeString(body.contentType)
  const teamId = normalizeString(body.teamId)
  const templateId = normalizeString(body.templateId)

  if (!kind) return badRequest(c, 'kind is required')
  if (!contentType) return badRequest(c, 'contentType is required')
  if (kind === 'templateOverlay' && contentType !== 'image/png') {
    return badRequest(c, 'templateOverlay must be image/png')
  }

  const ext = getExtension(contentType)
  if (!ext) return badRequest(c, 'Unsupported contentType')

  let key: string | null = null
  if (kind === 'tournamentLogo') {
    key = `config/tournaments/${id}/logos/tournament.${ext}`
  } else if (kind === 'orgLogo') {
    key = `config/tournaments/${id}/logos/org.${ext}`
  } else if (kind === 'teamLogo') {
    if (!teamId) return badRequest(c, 'teamId is required')
    key = `config/tournaments/${id}/teams/${teamId}.${ext}`
  } else if (kind === 'templateOverlay') {
    if (!templateId) return badRequest(c, 'templateId is required')
    if (!isSafeId(templateId)) return badRequest(c, 'templateId is invalid')
    const uploadId = randomUUID().slice(0, 8)
    key = `config/tournaments/${id}/overlays/${templateId}/${uploadId}.${ext}`
  }

  if (!key) return badRequest(c, 'kind is invalid')

  const { url, fields } = await createPresignedPost(s3, {
    Bucket: Resource.Media.name,
    Key: key,
    Fields: {
      'Content-Type': contentType,
    },
    Conditions: [
      ['content-length-range', 1, MAX_UPLOAD_BYTES],
      ['eq', '$Content-Type', contentType],
    ],
    Expires: 900,
  })

  const publicUrl = getPublicPath(key)
  const response: Record<string, unknown> = {
    uploadUrl: url,
    key,
    method: 'POST',
    fields,
  }
  if (publicUrl) response.publicUrl = publicUrl

  return c.json(response)
})

app.post('/admin/tournaments/:id/publish', async (c) => {
  const id = c.req.param('id')
  const draftKey = getConfigKey(id, 'draft')
  const publishedKey = getConfigKey(id, 'published')

  const draft = await readJsonFromS3<TournamentConfig>(draftKey)
  if (!draft) {
    return c.json({ error: 'Draft config not found' }, 404)
  }

  // Write published config with short cache (allows CloudFront to cache but still refreshes)
  await writeJsonToS3(publishedKey, draft, { cacheControl: 'public, max-age=60' })

  const list = (await readJsonFromS3<TournamentListEntry[]>(CONFIG_LIST_KEY)) ?? FALLBACK_TOURNAMENTS
  const nextList = list.map((entry) =>
    entry.id === id ? { ...entry, published: true } : entry
  )
  await writeJsonToS3(CONFIG_LIST_KEY, nextList, { cacheControl: 'public, max-age=60' })

  return c.json({ success: true })
})

// Export tournament bundle as ZIP
// Contains: config.json, tournament-logo.png, org-logo.png, teams/<team-id>.png
app.get('/admin/tournaments/:id/bundle', async (c) => {
  const id = c.req.param('id')

  const config =
    (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'draft'))) ??
    (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))) ??
    FALLBACK_CONFIGS[id]

  if (!config) {
    return c.json({ error: 'Tournament not found' }, 404)
  }

  const zip = new JSZip()

  // Add config.json
  zip.file('config.json', JSON.stringify(config, null, 2))

  // Helper to fetch and add file to zip
  const addAsset = async (key: string, zipPath: string) => {
    try {
      const result = await s3.send(
        new GetObjectCommand({
          Bucket: Resource.Media.name,
          Key: key,
        })
      )
      if (result.Body) {
        const data = await result.Body.transformToByteArray()
        zip.file(zipPath, data)
        return true
      }
    } catch {
      // File doesn't exist, skip
    }
    return false
  }

  // Add tournament logo
  await addAsset(config.branding.tournamentLogoKey, 'tournament-logo.png')

  // Add org logo
  if (config.branding.orgLogoKey) {
    await addAsset(config.branding.orgLogoKey, 'org-logo.png')
  }

  // Add team logos
  const teamPromises = config.teams.map((team) =>
    addAsset(team.logoKey, `teams/${team.id}.png`)
  )
  await Promise.all(teamPromises)

  const zipBuffer = await zip.generateAsync({ type: 'nodebuffer' })

  return new Response(zipBuffer, {
    headers: {
      'Content-Type': 'application/zip',
      'Content-Disposition': `attachment; filename="${id}-bundle.zip"`,
    },
  })
})

// Import tournament bundle from ZIP
// Expected structure: config.json (required), tournament-logo.png, org-logo.png, teams/<team-id>.png
app.post('/admin/tournaments/import-bundle', async (c) => {
  const arrayBuffer = await c.req.arrayBuffer()
  if (arrayBuffer.byteLength === 0) {
    return badRequest(c, 'Empty request body')
  }

  let zip: JSZip
  try {
    zip = await JSZip.loadAsync(arrayBuffer)
  } catch {
    return badRequest(c, 'Invalid ZIP file')
  }

  // Find and parse config.json
  const configFile = zip.file('config.json')
  if (!configFile) {
    return badRequest(c, 'ZIP must contain config.json at root level')
  }

  let config: TournamentConfig
  try {
    const configText = await configFile.async('text')
    config = JSON.parse(configText) as TournamentConfig
  } catch {
    return badRequest(c, 'config.json is not valid JSON')
  }

  // Validate required fields
  if (!config.id || typeof config.id !== 'string') {
    return badRequest(c, 'config.json must have a valid id')
  }
  if (!isSafeId(config.id)) {
    return badRequest(c, 'config.id must be 3-64 lowercase alphanumeric characters or hyphens')
  }
  if (!config.name || typeof config.name !== 'string') {
    return badRequest(c, 'config.json must have a valid name')
  }
  if (!config.year || typeof config.year !== 'number') {
    return badRequest(c, 'config.json must have a valid year')
  }

  // Validate team IDs
  for (const team of config.teams ?? []) {
    if (!isSafeId(team.id)) {
      return badRequest(c, `Team id "${team.id}" must be 3-64 lowercase alphanumeric characters or hyphens`)
    }
  }

  const id = config.id
  const now = nowIso()

  // Ensure branding paths are set correctly for this tournament
  config.branding = config.branding ?? { tournamentLogoKey: '' }
  config.branding.tournamentLogoKey = `config/tournaments/${id}/logos/tournament.png`
  if (config.branding.orgLogoKey) {
    config.branding.orgLogoKey = `config/tournaments/${id}/logos/org.png`
  }

  // Update team logo keys to match tournament structure
  config.teams = (config.teams ?? []).map((team) => ({
    ...team,
    logoKey: `config/tournaments/${id}/teams/${team.id}.png`,
  }))

  config.updatedAt = now
  config.createdAt = config.createdAt ?? now

  const results: {
    configSaved: boolean
    assetsUploaded: string[]
    assetsSkipped: string[]
  } = {
    configSaved: false,
    assetsUploaded: [],
    assetsSkipped: [],
  }

  // Save config
  await writeJsonToS3(getConfigKey(id, 'draft'), config)
  results.configSaved = true

  // Upload tournament logo
  const tournamentLogo = zip.file('tournament-logo.png')
  if (tournamentLogo) {
    const data = await tournamentLogo.async('nodebuffer')
    await s3.send(
      new PutObjectCommand({
        Bucket: Resource.Media.name,
        Key: config.branding.tournamentLogoKey,
        Body: data,
        ContentType: 'image/png',
      })
    )
    results.assetsUploaded.push('tournament-logo.png')
  } else {
    results.assetsSkipped.push('tournament-logo.png (not found in ZIP)')
  }

  // Upload org logo
  const orgLogo = zip.file('org-logo.png')
  if (orgLogo) {
    const data = await orgLogo.async('nodebuffer')
    await s3.send(
      new PutObjectCommand({
        Bucket: Resource.Media.name,
        Key: `config/tournaments/${id}/logos/org.png`,
        Body: data,
        ContentType: 'image/png',
      })
    )
    config.branding.orgLogoKey = `config/tournaments/${id}/logos/org.png`
    results.assetsUploaded.push('org-logo.png')
  }

  // Upload team logos from teams/ folder
  const teamsFolder = zip.folder('teams')
  if (teamsFolder) {
    const teamPromises: Promise<void>[] = []
    teamsFolder.forEach((relativePath, file) => {
      if (file.dir || !relativePath.toLowerCase().endsWith('.png')) return

      const filename = relativePath.split('/').pop() ?? relativePath
      if (!filename.toLowerCase().endsWith('.png')) return

      const teamId = filename.slice(0, -4)
      if (!isSafeId(teamId)) {
        results.assetsSkipped.push(`teams/${filename} (invalid team id)`)
        return
      }

      teamPromises.push(
        (async () => {
          const data = await file.async('nodebuffer')
          await s3.send(
            new PutObjectCommand({
              Bucket: Resource.Media.name,
              Key: `config/tournaments/${id}/teams/${teamId}.png`,
              Body: data,
              ContentType: 'image/png',
            })
          )
          results.assetsUploaded.push(`teams/${teamId}.png`)
        })()
      )
    })
    await Promise.all(teamPromises)
  }

  // Update tournament list
  const list = (await readJsonFromS3<TournamentListEntry[]>(CONFIG_LIST_KEY)) ?? FALLBACK_TOURNAMENTS
  const existing = list.find((entry) => entry.id === id)
  if (!existing) {
    list.push({ id, name: config.name, year: config.year, published: false })
    await writeJsonToS3(CONFIG_LIST_KEY, list, { cacheControl: 'public, max-age=60' })
  }

  // Re-save config with potentially updated orgLogoKey
  await writeJsonToS3(getConfigKey(id, 'draft'), config)

  return c.json({ tournament: config, results })
})

app.post('/uploads/presign', async (c) => {
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const { cardId, contentType, contentLength, kind } = body as PresignRequest

  if (typeof cardId !== 'string' || cardId.trim() === '') {
    return badRequest(c, 'cardId is required')
  }

  if (typeof contentType !== 'string') {
    return badRequest(c, 'contentType is required')
  }

  if (kind !== 'original' && kind !== 'crop' && kind !== 'render') {
    return badRequest(c, 'kind is invalid')
  }

  // Verify card exists before issuing presigned URL (prevents orphan uploads)
  const existingCard = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id: cardId },
    })
  )

  if (!existingCard.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  const editToken = normalizeString(c.req.header(EDIT_TOKEN_HEADER))
  if (!editToken) {
    return c.json({ error: 'Edit token is required' }, 401)
  }

  const card = existingCard.Item as Card
  if (!card.editToken || card.editToken !== editToken) {
    return c.json({ error: 'Invalid edit token' }, 403)
  }

  if (card.status !== 'draft') {
    return c.json({ error: 'Card is no longer editable' }, 409)
  }

  const length = typeof contentLength === 'number' ? contentLength : Number(contentLength)

  if (!Number.isFinite(length) || length <= 0) {
    return badRequest(c, 'contentLength must be a positive number')
  }

  if (length > MAX_UPLOAD_BYTES) {
    return badRequest(c, 'File is too large')
  }

  const allowedTypes = kind === 'render' ? ALLOWED_RENDER_TYPES : ALLOWED_UPLOAD_TYPES

  if (!allowedTypes.has(contentType)) {
    return badRequest(c, 'contentType is not allowed')
  }

  const key = getUploadKey(cardId, kind, contentType)

  if (!key) {
    return badRequest(c, 'Unsupported contentType for this upload kind')
  }

  const { url, fields } = await createPresignedPost(s3, {
    Bucket: Resource.Media.name,
    Key: key,
    Fields: {
      'Content-Type': contentType,
    },
    Conditions: [
      ['content-length-range', 1, MAX_UPLOAD_BYTES],
      ['eq', '$Content-Type', contentType],
    ],
    Expires: 900,
  })
  const publicUrl = kind === 'render' ? getPublicPath(key) : null
  const response: Record<string, unknown> = {
    uploadUrl: url,
    key,
    method: 'POST',
    fields,
  }
  if (publicUrl) response.publicUrl = publicUrl

  return c.json(response)
})

app.post('/cards', async (c) => {
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const now = nowIso()
  const id = randomUUID()
  const editToken = randomUUID()
  const input = pickCardInput(body)
  const { cardType, tournamentId, ...rest } = input

  if (!cardType || !isCardType(cardType)) {
    return badRequest(c, 'cardType is required')
  }
  if (!tournamentId) {
    return badRequest(c, 'tournamentId is required')
  }

  const fieldError = validateCardFields(input)
  if (fieldError) {
    return badRequest(c, fieldError)
  }

  const record: Card = {
    id,
    editToken,
    tournamentId,
    cardType,
    status: 'draft',
    createdAt: now,
    updatedAt: now,
    statusCreatedAt: buildStatusCreatedAt('draft', now),
    ...rest,
  }

  const createPhotoKeyError = validatePhotoKeys(id, record.photo)
  if (createPhotoKeyError) {
    return badRequest(c, createPhotoKeyError)
  }

  await ddb.send(
    new PutCommand({
      TableName: Resource.Cards.name,
      Item: record,
    })
  )

  return c.json(record, 201)
})

app.get('/cards', async (c) => {
  const statusParam = c.req.query('status')
  if (!isCardStatus(statusParam)) {
    return badRequest(c, 'status query param is required')
  }

  // Don't expose draft cards publicly - use /admin/cards for drafts
  if (statusParam === 'draft') {
    return c.json({ error: 'Draft cards require admin access' }, 403)
  }

  const tournamentId = c.req.query('tournamentId')
  const limitParam = c.req.query('limit')
  const limit = Math.min(100, Math.max(1, limitParam ? Number(limitParam) : 50))

  if (tournamentId) {
    const result = await ddb.send(
      new QueryCommand({
        TableName: Resource.Cards.name,
        IndexName: 'byTournamentStatus',
        KeyConditionExpression:
          '#tournamentId = :tournamentId AND begins_with(#statusCreatedAt, :statusPrefix)',
        ExpressionAttributeNames: {
          '#tournamentId': 'tournamentId',
          '#statusCreatedAt': 'statusCreatedAt',
        },
        ExpressionAttributeValues: {
          ':tournamentId': tournamentId,
          ':statusPrefix': `${statusParam}#`,
        },
        ScanIndexForward: false,
        Limit: limit,
      })
    )

    const items = (result.Items ?? []) as Card[]
    return c.json(items.map(toPublicCard))
  }

  const result = await ddb.send(
    new QueryCommand({
      TableName: Resource.Cards.name,
      IndexName: 'byStatus',
      KeyConditionExpression: '#status = :status',
      ExpressionAttributeNames: {
        '#status': 'status',
      },
      ExpressionAttributeValues: {
        ':status': statusParam,
      },
      ScanIndexForward: false,
      Limit: limit,
    })
  )

  const items = (result.Items ?? []) as Card[]
  return c.json(items.map(toPublicCard))
})

app.get('/cards/:id', async (c) => {
  const id = c.req.param('id')

  const result = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!result.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  return c.json(toPublicCard(result.Item as Card))
})

app.patch('/cards/:id', async (c) => {
  const id = c.req.param('id')
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const editToken = normalizeString(c.req.header(EDIT_TOKEN_HEADER))
  if (!editToken) {
    return c.json({ error: 'Edit token is required' }, 401)
  }

  const now = nowIso()
  if ('cardType' in body || 'tournamentId' in body || 'type' in body) {
    return badRequest(c, 'cardType and tournamentId cannot be changed')
  }

  const draft: UpdateDraft = { set: {}, remove: [] }

  let error =
    applyStringUpdate(draft, body.teamId, 'teamId', MAX_TEAM_LENGTH, 'teamId') ||
    applyStringUpdate(draft, body.teamName, 'teamName', MAX_TEAM_LENGTH, 'teamName') ||
    applyStringUpdate(draft, body.position, 'position', MAX_POSITION_LENGTH, 'position') ||
    applyStringUpdate(draft, body.templateId, 'templateId', MAX_TEMPLATE_LENGTH, 'templateId') ||
    applyStringUpdate(draft, body.firstName, 'firstName', MAX_NAME_LENGTH, 'firstName') ||
    applyStringUpdate(draft, body.lastName, 'lastName', MAX_NAME_LENGTH, 'lastName') ||
    applyStringUpdate(draft, body.photographer, 'photographer', MAX_PHOTOGRAPHER_LENGTH, 'photographer') ||
    applyStringUpdate(draft, body.title, 'title', MAX_TITLE_LENGTH, 'title') ||
    applyStringUpdate(draft, body.caption, 'caption', MAX_CAPTION_LENGTH, 'caption')

  if (!error && body.jerseyNumber !== undefined) {
    if (body.jerseyNumber === null) {
      pushRemove(draft, 'jerseyNumber')
    } else if (typeof body.jerseyNumber === 'string') {
      const trimmed = body.jerseyNumber.trim()
      if (!trimmed) {
        pushRemove(draft, 'jerseyNumber')
      } else if (!JERSEY_PATTERN.test(trimmed)) {
        error = 'jerseyNumber must be 1-2 digits'
      } else {
        pushSet(draft, 'jerseyNumber', trimmed)
      }
    } else {
      error = 'jerseyNumber must be a string'
    }
  }

  if (!error && body.photo !== undefined) {
    if (body.photo === null) {
      pushRemove(draft, 'photo')
    } else if (isRecord(body.photo)) {
      const photoUpdate: Card['photo'] = {}
      if (body.photo.originalKey !== undefined && body.photo.originalKey !== null) {
        if (typeof body.photo.originalKey !== 'string') {
          error = 'photo.originalKey must be a string'
        } else {
          const trimmed = body.photo.originalKey.trim()
          if (trimmed) {
            const lengthError = ensureMaxLength(trimmed, 1024, 'photo.originalKey')
            if (lengthError) {
              error = lengthError
            } else {
              photoUpdate.originalKey = trimmed
            }
          }
        }
      }

      if (!error && body.photo.cropKey !== undefined && body.photo.cropKey !== null) {
        if (typeof body.photo.cropKey !== 'string') {
          error = 'photo.cropKey must be a string'
        } else {
          const trimmed = body.photo.cropKey.trim()
          if (trimmed) {
            const lengthError = ensureMaxLength(trimmed, 1024, 'photo.cropKey')
            if (lengthError) {
              error = lengthError
            } else {
              photoUpdate.cropKey = trimmed
            }
          }
        }
      }

      if (!error && body.photo.width !== undefined && body.photo.width !== null) {
        const width = toNumber(body.photo.width)
        if (width === undefined) {
          error = 'photo.width must be a number'
        } else {
          photoUpdate.width = width
        }
      }

      if (!error && body.photo.height !== undefined && body.photo.height !== null) {
        const height = toNumber(body.photo.height)
        if (height === undefined) {
          error = 'photo.height must be a number'
        } else {
          photoUpdate.height = height
        }
      }

      if (!error && body.photo.crop !== undefined && body.photo.crop !== null) {
        const crop = pickCrop(body.photo.crop)
        if (!crop) {
          error = 'photo.crop is invalid'
        } else {
          photoUpdate.crop = crop
        }
      }

      if (!error) {
        if (Object.keys(photoUpdate).length === 0) {
          error = 'photo must include at least one field'
        } else {
          const photoKeyError = validatePhotoKeys(id, photoUpdate)
          if (photoKeyError) {
            error = photoKeyError
          } else {
            // Update individual photo fields to preserve existing data
            // (avoids wiping out other photo fields when only updating e.g. crop)
            for (const [key, value] of Object.entries(photoUpdate)) {
              pushSet(draft, `photo.${key}`, value)
            }
          }
        }
      }
    } else {
      error = 'photo must be an object'
    }
  }

  if (error) {
    return badRequest(c, error)
  }

  pushSet(draft, 'updatedAt', now)

  const entries = Object.entries(draft.set)
  const sets: string[] = []
  const removes: string[] = []
  const names: Record<string, string> = {}
  const nameMap = new Map<string, string>()
  const values: Record<string, unknown> = {}

  let valueIndex = 0
  let nameIndex = 0
  const nameFor = (segment: string) => {
    const existing = nameMap.get(segment)
    if (existing) return existing
    const key = `#n${nameIndex++}`
    nameMap.set(segment, key)
    names[key] = segment
    return key
  }
  const pathToExpression = (path: string) =>
    path
      .split('.')
      .map((segment) => nameFor(segment))
      .join('.')

  for (const [path, value] of entries) {
    const placeholder = `:v${valueIndex++}`
    values[placeholder] = value
    sets.push(`${pathToExpression(path)} = ${placeholder}`)
  }

  for (const path of draft.remove) {
    removes.push(pathToExpression(path))
  }

  values[':draft'] = 'draft'
  values[':editToken'] = editToken

  const updateExpressions = []
  if (sets.length > 0) updateExpressions.push(`SET ${sets.join(', ')}`)
  if (removes.length > 0) updateExpressions.push(`REMOVE ${removes.join(', ')}`)

  try {
    const result = await ddb.send(
      new UpdateCommand({
        TableName: Resource.Cards.name,
        Key: { id },
        UpdateExpression: updateExpressions.join(' '),
        ConditionExpression: 'attribute_exists(#id) AND #status = :draft AND #editToken = :editToken',
        ExpressionAttributeNames: {
          ...names,
          '#id': 'id',
          '#status': 'status',
          '#editToken': 'editToken',
        },
        ExpressionAttributeValues: values,
        ReturnValues: 'ALL_NEW',
      })
    )

    if (!result.Attributes) {
      return c.json({ error: 'Card not found' }, 404)
    }

    return c.json(result.Attributes)
  } catch (err) {
    if (err instanceof ConditionalCheckFailedException || (isRecord(err) && err.name === 'ConditionalCheckFailedException')) {
      const latest = await ddb.send(
        new GetCommand({
          TableName: Resource.Cards.name,
          Key: { id },
        })
      )

      if (!latest.Item) {
        return c.json({ error: 'Card not found' }, 404)
      }

      const current = latest.Item as Card
      if (!current.editToken || current.editToken !== editToken) {
        return c.json({ error: 'Invalid edit token' }, 403)
      }

      return c.json({ error: 'Card is no longer editable' }, 409)
    }
    throw err
  }
})

app.post('/cards/:id/submit', async (c) => {
  const id = c.req.param('id')

  const existing = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!existing.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  const card = existing.Item as Card
  const editToken = normalizeString(c.req.header(EDIT_TOKEN_HEADER))
  if (!editToken) {
    return c.json({ error: 'Edit token is required' }, 401)
  }
  if (!card.editToken || card.editToken !== editToken) {
    return c.json({ error: 'Invalid edit token' }, 403)
  }

  // Enforce status transition: only draft can be submitted (idempotent return)
  if (card.status !== 'draft') {
    return c.json(card)
  }

  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  let renderKey: string | undefined
  if (body.renderKey !== undefined && body.renderKey !== null) {
    if (typeof body.renderKey !== 'string' || body.renderKey.trim() === '') {
      return badRequest(c, 'renderKey must be a non-empty string')
    }
    renderKey = body.renderKey.trim()
  }

  let renderMeta: RenderMeta | undefined
  if (body.renderMeta !== undefined) {
    if (!renderKey) return badRequest(c, 'renderMeta requires renderKey')
    const parsed = parseRenderMeta(body.renderMeta, renderKey)
    if (typeof parsed === 'string') return badRequest(c, parsed)
    renderMeta = parsed
  }

  const submitValidationError = getSubmitValidationError(card)
  if (submitValidationError) {
    return badRequest(c, submitValidationError)
  }

  if (renderKey) {
    // Validate renderKey format: must be renders/<cardId>/<id>.png
    const renderKeyPattern = new RegExp(`^renders/${id}/[a-f0-9-]+\\.png$`)
    if (!renderKeyPattern.test(renderKey)) {
      return badRequest(c, 'Invalid renderKey format')
    }

    try {
      await s3.send(
        new HeadObjectCommand({
          Bucket: Resource.Media.name,
          Key: renderKey,
        })
      )
    } catch {
      return badRequest(c, 'renderKey not found in storage')
    }
  }

  const now = nowIso()
  const statusCreatedAt = buildStatusCreatedAt('submitted', now)
  try {
    const setExpressions = ['#status = :status', '#updatedAt = :updatedAt', '#statusCreatedAt = :statusCreatedAt']
    const expressionAttributeNames: Record<string, string> = {
      '#status': 'status',
      '#updatedAt': 'updatedAt',
      '#statusCreatedAt': 'statusCreatedAt',
    }
    const expressionAttributeValues: Record<string, unknown> = {
      ':status': 'submitted',
      ':draft': 'draft',
      ':updatedAt': now,
      ':statusCreatedAt': statusCreatedAt,
    }

    if (renderKey) {
      setExpressions.push('#renderKey = :renderKey')
      expressionAttributeNames['#renderKey'] = 'renderKey'
      expressionAttributeValues[':renderKey'] = renderKey
    }

    if (renderMeta) {
      setExpressions.push('#renderMeta = :renderMeta')
      expressionAttributeNames['#renderMeta'] = 'renderMeta'
      expressionAttributeValues[':renderMeta'] = renderMeta
    }

    const result = await ddb.send(
      new UpdateCommand({
        TableName: Resource.Cards.name,
        Key: { id },
        UpdateExpression: `SET ${setExpressions.join(', ')}`,
        ConditionExpression: '#status = :draft',
        ExpressionAttributeNames: expressionAttributeNames,
        ExpressionAttributeValues: expressionAttributeValues,
        ReturnValues: 'ALL_NEW',
      })
    )

    if (result.Attributes) {
      return c.json(result.Attributes)
    }

    const next: Card = {
      ...card,
      renderKey: renderKey ?? card.renderKey,
      renderMeta: renderMeta ?? card.renderMeta,
      status: 'submitted',
      updatedAt: now,
      statusCreatedAt,
    }
    return c.json(next)
  } catch (err) {
    if (err instanceof ConditionalCheckFailedException || (isRecord(err) && err.name === 'ConditionalCheckFailedException')) {
      const latest = await ddb.send(
        new GetCommand({
          TableName: Resource.Cards.name,
          Key: { id },
        })
      )

      if (latest.Item) {
        return c.json(latest.Item)
      }

      return c.json({ error: 'Card not found' }, 404)
    }
    throw err
  }
})

// Admin cards listing - allows all statuses including drafts
app.get('/admin/cards', async (c) => {
  const statusParam = c.req.query('status')
  if (!isCardStatus(statusParam)) {
    return badRequest(c, 'status query param is required')
  }

  const tournamentId = c.req.query('tournamentId')
  const limitParam = c.req.query('limit')
  const limit = Math.min(100, Math.max(1, limitParam ? Number(limitParam) : 50))

  if (tournamentId) {
    const result = await ddb.send(
      new QueryCommand({
        TableName: Resource.Cards.name,
        IndexName: 'byTournamentStatus',
        KeyConditionExpression:
          '#tournamentId = :tournamentId AND begins_with(#statusCreatedAt, :statusPrefix)',
        ExpressionAttributeNames: {
          '#tournamentId': 'tournamentId',
          '#statusCreatedAt': 'statusCreatedAt',
        },
        ExpressionAttributeValues: {
          ':tournamentId': tournamentId,
          ':statusPrefix': `${statusParam}#`,
        },
        ScanIndexForward: false,
        Limit: limit,
      })
    )
    return c.json(result.Items ?? [])
  }

  const result = await ddb.send(
    new QueryCommand({
      TableName: Resource.Cards.name,
      IndexName: 'byStatus',
      KeyConditionExpression: '#status = :status',
      ExpressionAttributeNames: {
        '#status': 'status',
      },
      ExpressionAttributeValues: {
        ':status': statusParam,
      },
      ScanIndexForward: false,
      Limit: limit,
    })
  )
  return c.json(result.Items ?? [])
})

app.patch('/admin/cards/:id', async (c) => {
  const id = c.req.param('id')
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const keys = Object.keys(body)
  if (keys.length === 0 || keys.some((key) => key !== 'templateId')) {
    return badRequest(c, 'Only templateId can be updated')
  }

  const templateIdInput = body.templateId
  let templateId: string | null = null
  let removeTemplateId = false

  if (templateIdInput === null) {
    removeTemplateId = true
  } else if (typeof templateIdInput === 'string') {
    const trimmed = templateIdInput.trim()
    if (!trimmed) {
      removeTemplateId = true
    } else {
      const error = ensureMaxLength(trimmed, MAX_TEMPLATE_LENGTH, 'templateId')
      if (error) return badRequest(c, error)
      templateId = trimmed
    }
  } else {
    return badRequest(c, 'templateId must be a string')
  }

  const now = nowIso()
  const setExpressions = ['#updatedAt = :updatedAt']
  const removeExpressions: string[] = []
  const names: Record<string, string> = {
    '#id': 'id',
    '#updatedAt': 'updatedAt',
    '#templateId': 'templateId',
  }
  const values: Record<string, unknown> = {
    ':updatedAt': now,
  }

  if (templateId) {
    setExpressions.push('#templateId = :templateId')
    values[':templateId'] = templateId
  } else if (removeTemplateId) {
    removeExpressions.push('#templateId')
  }

  const updateExpression = `SET ${setExpressions.join(', ')}${
    removeExpressions.length > 0 ? ` REMOVE ${removeExpressions.join(', ')}` : ''
  }`

  const result = await ddb.send(
    new UpdateCommand({
      TableName: Resource.Cards.name,
      Key: { id },
      UpdateExpression: updateExpression,
      ConditionExpression: 'attribute_exists(#id)',
      ExpressionAttributeNames: names,
      ExpressionAttributeValues: values,
      ReturnValues: 'ALL_NEW',
    })
  )

  if (!result.Attributes) {
    return c.json({ error: 'Card not found' }, 404)
  }

  return c.json(result.Attributes)
})

app.get('/admin/cards/:id/photo-url', async (c) => {
  const id = c.req.param('id')
  const existing = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!existing.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  const card = existing.Item as Card
  const originalKey = card.photo?.originalKey
  if (!originalKey) {
    return c.json({ error: 'Card has no original photo' }, 400)
  }

  const url = await getSignedUrl(
    s3,
    new GetObjectCommand({
      Bucket: Resource.Media.name,
      Key: originalKey,
    }),
    { expiresIn: 300 }
  )

  return c.json({ url })
})

app.post('/admin/cards/:id/renders/presign', async (c) => {
  const id = c.req.param('id')
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const existing = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!existing.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  const card = existing.Item as Card
  if (card.status === 'draft') {
    return badRequest(c, 'Draft cards cannot be rendered')
  }

  const contentType = normalizeString(body.contentType)
  if (!contentType) return badRequest(c, 'contentType is required')

  const length = typeof body.contentLength === 'number' ? body.contentLength : Number(body.contentLength)
  if (!Number.isFinite(length) || length <= 0) {
    return badRequest(c, 'contentLength must be a positive number')
  }

  if (length > MAX_UPLOAD_BYTES) {
    return badRequest(c, 'File is too large')
  }

  if (!ALLOWED_RENDER_TYPES.has(contentType)) {
    return badRequest(c, 'contentType is not allowed')
  }

  const key = getUploadKey(id, 'render', contentType)
  if (!key) return badRequest(c, 'Unsupported contentType for render upload')

  const { url, fields } = await createPresignedPost(s3, {
    Bucket: Resource.Media.name,
    Key: key,
    Fields: {
      'Content-Type': contentType,
    },
    Conditions: [
      ['content-length-range', 1, MAX_UPLOAD_BYTES],
      ['eq', '$Content-Type', contentType],
    ],
    Expires: 900,
  })

  return c.json({
    uploadUrl: url,
    key,
    method: 'POST',
    fields,
  })
})

app.post('/admin/cards/:id/renders/commit', async (c) => {
  const id = c.req.param('id')
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const renderKey = normalizeString(body.renderKey)
  if (!renderKey) return badRequest(c, 'renderKey is required')

  if (body.renderMeta === undefined) {
    return badRequest(c, 'renderMeta is required')
  }

  const renderMeta = parseRenderMeta(body.renderMeta, renderKey)
  if (typeof renderMeta === 'string') {
    return badRequest(c, renderMeta)
  }

  // Validate renderKey format: must be renders/<cardId>/<id>.png
  const renderKeyPattern = new RegExp(`^renders/${id}/[a-f0-9-]+\\.png$`)
  if (!renderKeyPattern.test(renderKey)) {
    return badRequest(c, 'Invalid renderKey format')
  }

  const existing = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!existing.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  const card = existing.Item as Card
  if (card.status === 'draft') {
    return badRequest(c, 'Draft cards cannot be rendered')
  }

  try {
    await s3.send(
      new HeadObjectCommand({
        Bucket: Resource.Media.name,
        Key: renderKey,
      })
    )
  } catch {
    return badRequest(c, 'renderKey not found in storage')
  }

  const now = nowIso()
  const statusCreatedAt = buildStatusCreatedAt('rendered', now)
  const result = await ddb.send(
    new UpdateCommand({
      TableName: Resource.Cards.name,
      Key: { id },
      UpdateExpression:
        'SET #renderKey = :renderKey, #renderMeta = :renderMeta, #status = :status, #updatedAt = :updatedAt, #statusCreatedAt = :statusCreatedAt',
      ExpressionAttributeNames: {
        '#renderKey': 'renderKey',
        '#renderMeta': 'renderMeta',
        '#status': 'status',
        '#updatedAt': 'updatedAt',
        '#statusCreatedAt': 'statusCreatedAt',
      },
      ExpressionAttributeValues: {
        ':renderKey': renderKey,
        ':renderMeta': renderMeta,
        ':status': 'rendered',
        ':updatedAt': now,
        ':statusCreatedAt': statusCreatedAt,
      },
      ReturnValues: 'ALL_NEW',
    })
  )

  return c.json(result.Attributes ?? {
    ...card,
    renderKey,
    renderMeta,
    status: 'rendered',
    updatedAt: now,
    statusCreatedAt,
  })
})

app.post('/admin/cards/:id/render', async (c) => {
  const id = c.req.param('id')
  const now = nowIso()
  const existing = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!existing.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  const card = existing.Item as Card
  if (card.status !== 'submitted') {
    return badRequest(c, 'Only submitted cards can be marked rendered')
  }
  const statusCreatedAt = buildStatusCreatedAt('rendered', now)

  const result = await ddb.send(
    new UpdateCommand({
      TableName: Resource.Cards.name,
      Key: { id },
      UpdateExpression: 'SET #status = :status, #updatedAt = :updatedAt, #statusCreatedAt = :statusCreatedAt',
      ExpressionAttributeNames: {
        '#status': 'status',
        '#updatedAt': 'updatedAt',
        '#statusCreatedAt': 'statusCreatedAt',
      },
      ExpressionAttributeValues: {
        ':status': 'rendered',
        ':updatedAt': now,
        ':statusCreatedAt': statusCreatedAt,
      },
      ReturnValues: 'ALL_NEW',
    })
  )

  return c.json(result.Attributes ?? card)
})

app.get('/admin/cards/:id/download-url', async (c) => {
  const id = c.req.param('id')
  const existing = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!existing.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  const card = existing.Item as Card
  if (!card.renderKey) {
    return c.json({ error: 'Card has no render' }, 400)
  }

  const url = await getSignedUrl(
    s3,
    new GetObjectCommand({
      Bucket: Resource.Media.name,
      Key: card.renderKey,
      ResponseContentDisposition: `attachment; filename="${id}.png"`,
    }),
    { expiresIn: 300 }
  )

  return c.json({ url })
})

app.delete('/admin/cards/:id', async (c) => {
  const id = c.req.param('id')
  const existing = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!existing.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  const card = existing.Item as Card
  if (card.status !== 'draft') {
    return badRequest(c, 'Only draft cards can be deleted')
  }

  await ddb.send(
    new DeleteCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )
  return c.json({ success: true })
})

app.notFound((c) => c.json({ error: 'Not Found' }, 404))

app.onError((err, c) => {
  console.error('Server error:', err)
  const message = err instanceof Error ? err.message : 'Internal Server Error'
  return c.json({ error: message }, 500)
})

export default app
</file>

</files>
