This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
client/
  public/
    vite.svg
  src/
    App.tsx
    index.css
    main.tsx
    router.tsx
    sst-env.d.ts
    vite-env.d.ts
  .gitignore
  eslint.config.js
  index.html
  package.json
  README.md
  sst-env.d.ts
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
server/
  src/
    dev.ts
    index.ts
    lambda.ts
  .gitignore
  package.json
  README.md
  sst-env.d.ts
  tsconfig.json
shared/
  src/
    types/
      index.ts
    index.ts
  package.json
  sst-env.d.ts
  tsconfig.json
.gitignore
instructions.md
LICENSE
package.json
PLAN.md
pnpm-workspace.yaml
README.md
sst-env.d.ts
sst.config.ts
tsconfig.json
turbo.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="client/src/App.tsx">
import { useMemo, useState, type ChangeEvent } from 'react'
import Cropper, { type Area, type Point } from 'react-easy-crop'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { ApiResponse, CardDesign, CropRect } from 'shared'

type FormState = {
  cardType: string
  team: string
  position: string
  jerseyNumber: string
  firstName: string
  lastName: string
  photographer: string
}

type SavePayload = {
  type?: string
  teamId?: string
  position?: string
  jerseyNumber?: string
  firstName?: string
  lastName?: string
  photographer?: string
  photo?: {
    crop?: CropRect
  }
}

type Rotation = CropRect['rotateDeg']

type SaveDraftInput = {
  id?: string
  payload: SavePayload
}

const initialForm: FormState = {
  cardType: '',
  team: '',
  position: '',
  jerseyNumber: '',
  firstName: '',
  lastName: '',
  photographer: '',
}

const rotationSteps: Rotation[] = [0, 90, 180, 270]

const clamp = (value: number, min: number, max: number) =>
  Math.min(Math.max(value, min), max)

async function fetchHello(): Promise<ApiResponse> {
  const res = await fetch('/api/hello')
  if (!res.ok) {
    throw new Error('API request failed')
  }
  return res.json()
}

async function saveDraft(input: SaveDraftInput): Promise<CardDesign> {
  const { id, payload } = input
  const endpoint = id ? `/api/cards/${id}` : '/api/cards'
  const method = id ? 'PATCH' : 'POST'

  const res = await fetch(endpoint, {
    method,
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  })

  if (!res.ok) {
    throw new Error('Could not save draft')
  }

  return res.json()
}

function App() {
  const [form, setForm] = useState<FormState>(initialForm)
  const [photoUrl, setPhotoUrl] = useState<string | null>(null)
  const [photoName, setPhotoName] = useState<string | null>(null)
  const [crop, setCrop] = useState<Point>({ x: 0, y: 0 })
  const [zoom, setZoom] = useState(1)
  const [rotation, setRotation] = useState<Rotation>(0)
  const [normalizedCrop, setNormalizedCrop] = useState<CropRect | null>(null)
  const [cardId, setCardId] = useState<string | null>(null)
  const [savedCard, setSavedCard] = useState<CardDesign | null>(null)

  const helloQuery = useQuery({
    queryKey: ['hello'],
    queryFn: fetchHello,
    enabled: false,
  })

  const saveMutation = useMutation({
    mutationFn: saveDraft,
    onSuccess: (data) => {
      setCardId(data.id)
      setSavedCard(data)
    },
  })

  const statusMessage = useMemo(() => {
    if (saveMutation.isPending) return 'Saving draft...'
    if (saveMutation.isSuccess) return 'Draft saved'
    return 'Not saved'
  }, [saveMutation.isPending, saveMutation.isSuccess])

  const errorMessage = useMemo(() => {
    const error = saveMutation.error ?? helloQuery.error
    if (!error) return null
    return error instanceof Error ? error.message : 'Something went wrong'
  }, [saveMutation.error, helloQuery.error])

  const handleFieldChange = (key: keyof FormState) =>
    (event: ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
      setForm((prev) => ({ ...prev, [key]: event.target.value }))
    }

  const handleFileChange = (event: ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) return

    const nextUrl = URL.createObjectURL(file)

    setPhotoUrl((prev) => {
      if (prev) URL.revokeObjectURL(prev)
      return nextUrl
    })

    setPhotoName(file.name)
  }

  const handleCropComplete = (area: Area) => {
    setNormalizedCrop({
      x: Number((area.x / 100).toFixed(4)),
      y: Number((area.y / 100).toFixed(4)),
      w: Number((area.width / 100).toFixed(4)),
      h: Number((area.height / 100).toFixed(4)),
      rotateDeg: rotation,
    })
  }

  const handleRotate = () => {
    setRotation((prev) => {
      const nextIndex = (rotationSteps.indexOf(prev) + 1) % rotationSteps.length
      return rotationSteps[nextIndex]
    })
  }

  const handleZoom = (delta: number) => {
    setZoom((prev) => clamp(Number((prev + delta).toFixed(2)), 1, 3))
  }

  const handleResetCrop = () => {
    setCrop({ x: 0, y: 0 })
    setZoom(1)
    setRotation(0)
  }

  const buildPayload = (): SavePayload => ({
    type: form.cardType || undefined,
    teamId: form.team || undefined,
    position: form.position || undefined,
    jerseyNumber: form.jerseyNumber || undefined,
    firstName: form.firstName || undefined,
    lastName: form.lastName || undefined,
    photographer: form.photographer || undefined,
    photo: normalizedCrop ? { crop: normalizedCrop } : undefined,
  })

  const handleSaveDraft = () => {
    saveMutation.mutate({ id: cardId ?? undefined, payload: buildPayload() })
  }

  const displayName = useMemo(() => {
    const full = `${form.firstName} ${form.lastName}`.trim()
    return full.length > 0 ? full : 'Player Name'
  }, [form.firstName, form.lastName])

  return (
    <div className="app-shell min-h-screen">
      <div className="mx-auto flex max-w-6xl flex-col gap-10 px-6 py-12">
        <header className="flex flex-col gap-4">
          <p className="text-xs uppercase tracking-[0.3em] text-slate-400">
            Trading Card Studio
          </p>
          <div className="space-y-2">
            <h1 className="font-display text-4xl text-white md:text-5xl">
              Build your card from a single crop
            </h1>
            <p className="max-w-2xl text-base text-slate-300">
              Upload a photo, drag to frame the shot, and save a draft. This is the
              starting point for the full render pipeline.
            </p>
          </div>
        </header>

        <div className="grid gap-10 lg:grid-cols-[1.05fr_0.95fr]">
          <section className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
            <div className="flex flex-wrap items-center justify-between gap-4">
              <div>
                <h2 className="text-lg font-semibold text-white">Card Details</h2>
                <p className="text-sm text-slate-400">
                  Draft ID: {cardId ?? 'Not created'}
                </p>
              </div>
              <div className="flex items-center gap-3 text-xs text-slate-400">
                <button
                  type="button"
                  onClick={() => helloQuery.refetch()}
                  className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
                >
                  Ping API
                </button>
                <span>
                  {helloQuery.data ? 'Connected' : 'Idle'}
                </span>
              </div>
            </div>

            <div className="mt-6 grid gap-4 sm:grid-cols-2">
              <label className="text-xs uppercase tracking-wide text-slate-400">
                Card Type
                <select
                  value={form.cardType}
                  onChange={handleFieldChange('cardType')}
                  className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                >
                  <option value="">Select type</option>
                  <option value="player">Player</option>
                  <option value="staff">Staff</option>
                  <option value="media">Media</option>
                  <option value="official">Official</option>
                </select>
              </label>
              <label className="text-xs uppercase tracking-wide text-slate-400">
                Team
                <input
                  value={form.team}
                  onChange={handleFieldChange('team')}
                  className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  placeholder="Bay Area Breakers"
                />
              </label>
              <label className="text-xs uppercase tracking-wide text-slate-400">
                Position
                <input
                  value={form.position}
                  onChange={handleFieldChange('position')}
                  className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  placeholder="Keeper"
                />
              </label>
              <label className="text-xs uppercase tracking-wide text-slate-400">
                Jersey Number
                <input
                  value={form.jerseyNumber}
                  onChange={handleFieldChange('jerseyNumber')}
                  className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  placeholder="15"
                />
              </label>
              <label className="text-xs uppercase tracking-wide text-slate-400">
                First Name
                <input
                  value={form.firstName}
                  onChange={handleFieldChange('firstName')}
                  className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  placeholder="Brandon"
                />
              </label>
              <label className="text-xs uppercase tracking-wide text-slate-400">
                Last Name
                <input
                  value={form.lastName}
                  onChange={handleFieldChange('lastName')}
                  className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  placeholder="Williams"
                />
              </label>
              <label className="text-xs uppercase tracking-wide text-slate-400 sm:col-span-2">
                Photo Credit
                <input
                  value={form.photographer}
                  onChange={handleFieldChange('photographer')}
                  className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
                  placeholder="Paul Schiopu"
                />
              </label>
            </div>

            <div className="mt-6">
              <label className="text-xs uppercase tracking-wide text-slate-400">
                Player Photo
                <div className="mt-2 flex flex-wrap items-center gap-3">
                  <label className="flex cursor-pointer items-center gap-2 rounded-full border border-white/15 px-4 py-2 text-xs text-white transition hover:border-white/40">
                    <input
                      type="file"
                      accept="image/*"
                      className="sr-only"
                      onChange={handleFileChange}
                    />
                    Upload
                  </label>
                  <span className="text-xs text-slate-400">
                    {photoName ?? 'No file selected'}
                  </span>
                </div>
              </label>
            </div>

            <div className="mt-6 flex flex-wrap items-center gap-4">
              <button
                type="button"
                onClick={handleSaveDraft}
                disabled={saveMutation.isPending}
                className="rounded-full bg-white px-5 py-2 text-xs font-semibold text-slate-900 transition hover:bg-slate-100 disabled:cursor-not-allowed disabled:opacity-70"
              >
                {cardId ? 'Update Draft' : 'Create Draft'}
              </button>
              <span className="text-xs text-slate-400">{statusMessage}</span>
              {errorMessage ? (
                <span className="text-xs text-rose-300">{errorMessage}</span>
              ) : null}
            </div>
          </section>

          <section className="space-y-6">
            <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
              <div className="flex items-center justify-between">
                <div>
                  <h2 className="text-lg font-semibold text-white">Live Crop</h2>
                  <p className="text-sm text-slate-400">
                    Drag the image to frame it. Scroll or pinch to zoom.
                  </p>
                </div>
                <div className="text-xs text-slate-400">
                  Rotation: {rotation} deg
                </div>
              </div>

              <div className="mt-5">
                <div className="relative aspect-[3/4] w-full overflow-hidden rounded-[28px] border border-white/10 bg-slate-950/60 shadow-[0_20px_60px_rgba(3,7,18,0.6)]">
                  {photoUrl ? (
                    <Cropper
                      image={photoUrl}
                      crop={crop}
                      zoom={zoom}
                      rotation={rotation}
                      aspect={3 / 4}
                      onCropChange={setCrop}
                      onZoomChange={setZoom}
                      onCropComplete={handleCropComplete}
                      showGrid={false}
                      classes={{
                        containerClassName: 'cropper-container',
                        cropAreaClassName: 'cropper-area',
                      }}
                    />
                  ) : (
                    <div className="flex h-full w-full items-center justify-center text-sm text-slate-400">
                      Upload a photo to start cropping
                    </div>
                  )}
                </div>
              </div>

              <div className="mt-5 flex flex-wrap items-center gap-3">
                <button
                  type="button"
                  onClick={() => handleZoom(0.2)}
                  className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
                >
                  Zoom In
                </button>
                <button
                  type="button"
                  onClick={() => handleZoom(-0.2)}
                  className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
                >
                  Zoom Out
                </button>
                <button
                  type="button"
                  onClick={handleRotate}
                  className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
                >
                  Rotate 90 deg
                </button>
                <button
                  type="button"
                  onClick={handleResetCrop}
                  className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
                >
                  Reset
                </button>
              </div>
            </div>

            <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
              <h3 className="text-sm uppercase tracking-[0.2em] text-slate-400">
                Preview Meta
              </h3>
              <div className="mt-4 space-y-3">
                <div className="font-display text-2xl text-white">
                  {displayName}
                </div>
                <div className="text-sm text-slate-300">
                  {form.position || 'Position'} / {form.team || 'Team'}
                </div>
                <div className="text-xs text-slate-400">
                  Crop: {normalizedCrop ? `${normalizedCrop.w} x ${normalizedCrop.h}` : '-'}
                </div>
                {savedCard ? (
                  <div className="rounded-2xl border border-white/10 bg-slate-950/60 px-4 py-3 text-xs text-slate-300">
                    Saved as <span className="text-white">{savedCard.id}</span>
                  </div>
                ) : null}
              </div>
            </div>
          </section>
        </div>
      </div>
    </div>
  )
}

export default App
</file>

<file path="client/src/index.css">
@import url('https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400..700&family=Sora:wght@300..700&display=swap');
@import "tailwindcss";

:root {
  --font-sans: "Sora", "Avenir Next", "Helvetica Neue", sans-serif;
  --font-display: "Fraunces", "Iowan Old Style", serif;
  --ink: #eef2ff;
  --muted: #94a3b8;
  --panel: rgba(255, 255, 255, 0.06);
}

body {
  font-family: var(--font-sans);
  color: var(--ink);
  background-color: #0b0f1a;
}

.font-display {
  font-family: var(--font-display);
  letter-spacing: -0.02em;
}

.app-shell {
  background:
    radial-gradient(60rem 60rem at -10% -15%, rgba(94, 234, 212, 0.2), transparent 55%),
    radial-gradient(45rem 45rem at 110% 10%, rgba(248, 113, 113, 0.18), transparent 55%),
    radial-gradient(35rem 35rem at 50% 120%, rgba(129, 140, 248, 0.2), transparent 60%),
    linear-gradient(135deg, rgba(15, 23, 42, 0.85), rgba(2, 6, 23, 0.95));
}

.cropper-container {
  border-radius: 1.5rem;
}

.cropper-area {
  border: 1px solid rgba(255, 255, 255, 0.65);
  box-shadow: 0 0 0 9999px rgba(2, 6, 23, 0.7);
}
</file>

<file path="client/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { RouterProvider } from '@tanstack/react-router'
import { router } from './router'
import './index.css'

const queryClient = new QueryClient()

declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router
  }
}

const rootElement = document.getElementById('root')

if (!rootElement) {
  throw new Error('Root element not found')
}

createRoot(rootElement).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <RouterProvider router={router} />
    </QueryClientProvider>
  </StrictMode>
)
</file>

<file path="client/src/router.tsx">
import { createRootRoute, createRoute, createRouter, Outlet } from '@tanstack/react-router'
import App from './App'

const rootRoute = createRootRoute({
  component: () => <Outlet />,
})

const indexRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/',
  component: App,
})

const routeTree = rootRoute.addChildren([indexRoute])

export const router = createRouter({ routeTree })
</file>

<file path="client/src/sst-env.d.ts">
/* This file is auto-generated by SST. Do not edit. */
/* tslint:disable */
/* eslint-disable */
/// <reference types="vite/client" />
interface ImportMetaEnv {

}
interface ImportMeta {
  readonly env: ImportMetaEnv
}
</file>

<file path="client/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="client/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="client/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)
</file>

<file path="client/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BHVR</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="client/package.json">
{
  "name": "client",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.18",
    "@tanstack/react-query": "^5.90.12",
    "@tanstack/react-router": "^1.141.6",
    "@tanstack/react-router-devtools": "^1.141.6",
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "react-easy-crop": "^5.5.6",
    "server": "workspace:*",
    "shared": "workspace:*",
    "tailwindcss": "^4.1.18"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.2",
    "@types/node": "^22.19.2",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^4.7.0",
    "eslint": "^9.39.2",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.7.3",
    "typescript-eslint": "^8.49.0",
    "vite": "^6.4.1"
  }
}
</file>

<file path="client/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```
</file>

<file path="client/sst-env.d.ts">
/* This file is auto-generated by SST. Do not edit. */
/* tslint:disable */
/* eslint-disable */
/* deno-fmt-ignore-file */

/// <reference path="../sst-env.d.ts" />

import "sst"
export {}
</file>

<file path="client/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="client/tsconfig.json">
{
  "extends": "../tsconfig.json",
  "files": [],
  "references": [{ "path": "./tsconfig.node.json" }, { "path": "./tsconfig.app.json"}]
}
</file>

<file path="client/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="client/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
	plugins: [react(), tailwindcss()],
	server: {
		proxy: {
			"/api": {
				target: "http://localhost:3000",
				changeOrigin: true,
				rewrite: (path) => path.replace(/^\/api/, ""),
			},
		},
	},
});
</file>

<file path="server/src/dev.ts">
import { serve } from '@hono/node-server'
import app from './index.js'

const port = Number(process.env.PORT ?? 3000)

console.log(`Hono dev server running on http://localhost:${port}`)

serve({
  fetch: app.fetch,
  port,
})
</file>

<file path="server/src/index.ts">
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { Resource } from 'sst'
import { randomUUID } from 'node:crypto'
import { getSignedUrl } from '@aws-sdk/s3-request-presigner'
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3'
import { DynamoDBClient } from '@aws-sdk/client-dynamodb'
import { DynamoDBDocumentClient, GetCommand, PutCommand } from '@aws-sdk/lib-dynamodb'
import type { ApiResponse, CardDesign, CardStatus, CropRect } from 'shared'

const app = new Hono()

app.use(cors())

const s3 = new S3Client({})
const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}))

const MAX_UPLOAD_BYTES = 15 * 1024 * 1024
const ALLOWED_UPLOAD_TYPES = new Set(['image/jpeg', 'image/png', 'image/webp'])
const ALLOWED_RENDER_TYPES = new Set(['image/png'])
const RENDER_EXTENSION = 'png'

type PresignKind = 'original' | 'crop' | 'render'

type PresignRequest = {
  cardId: string
  contentType: string
  contentLength: number
  kind: PresignKind
}

const isRecord = (value: unknown): value is Record<string, unknown> =>
  typeof value === 'object' && value !== null && !Array.isArray(value)

const nowIso = () => new Date().toISOString()

const isCardStatus = (value: unknown): value is CardStatus =>
  value === 'draft' || value === 'submitted' || value === 'rendered'

const toNumber = (value: unknown): number | undefined => {
  if (typeof value === 'number' && Number.isFinite(value)) {
    return value
  }

  if (typeof value === 'string' && value.trim() !== '') {
    const parsed = Number(value)
    return Number.isFinite(parsed) ? parsed : undefined
  }

  return undefined
}

const toRotateDeg = (value: unknown): CropRect['rotateDeg'] | undefined => {
  const numeric = toNumber(value)

  if (numeric === 0 || numeric === 90 || numeric === 180 || numeric === 270) {
    return numeric
  }

  return undefined
}

const pickCrop = (value: unknown): CropRect | undefined => {
  if (!isRecord(value)) return undefined

  const x = toNumber(value.x)
  const y = toNumber(value.y)
  const w = toNumber(value.w)
  const h = toNumber(value.h)

  if (x === undefined || y === undefined || w === undefined || h === undefined) {
    return undefined
  }

  const rotateDeg = toRotateDeg(value.rotateDeg) ?? 0

  return { x, y, w, h, rotateDeg }
}

const pickPhoto = (value: unknown): CardDesign['photo'] | undefined => {
  if (!isRecord(value)) return undefined

  const photo: CardDesign['photo'] = {}

  if (typeof value.originalKey === 'string') photo.originalKey = value.originalKey
  if (typeof value.cropKey === 'string') photo.cropKey = value.cropKey

  const width = toNumber(value.width)
  const height = toNumber(value.height)

  if (width !== undefined) photo.width = width
  if (height !== undefined) photo.height = height

  const crop = pickCrop(value.crop)
  if (crop) photo.crop = crop

  return Object.keys(photo).length > 0 ? photo : undefined
}

const pickCardInput = (
  input: Record<string, unknown>,
  options?: { allowStatus?: boolean }
): Partial<CardDesign> => {
  const data: Partial<CardDesign> = {}

  if (typeof input.templateId === 'string') data.templateId = input.templateId
  if (typeof input.type === 'string') data.type = input.type
  if (typeof input.teamId === 'string') data.teamId = input.teamId
  if (typeof input.position === 'string') data.position = input.position
  if (typeof input.jerseyNumber === 'string') data.jerseyNumber = input.jerseyNumber
  if (typeof input.firstName === 'string') data.firstName = input.firstName
  if (typeof input.lastName === 'string') data.lastName = input.lastName
  if (typeof input.photographer === 'string') data.photographer = input.photographer
  if (typeof input.renderKey === 'string') data.renderKey = input.renderKey

  const photo = pickPhoto(input.photo)
  if (photo) data.photo = photo

  if (options?.allowStatus && isCardStatus(input.status)) {
    data.status = input.status
  }

  return data
}

const getExtension = (contentType: string) => {
  switch (contentType) {
    case 'image/jpeg':
      return 'jpg'
    case 'image/png':
      return 'png'
    case 'image/webp':
      return 'webp'
    default:
      return null
  }
}

const getUploadKey = (cardId: string, kind: PresignKind, contentType: string) => {
  if (kind === 'render') {
    return `renders/${cardId}.${RENDER_EXTENSION}`
  }

  const ext = getExtension(contentType)
  if (!ext) return null

  const prefix = kind === 'original' ? 'uploads/original' : 'uploads/crop'
  return `${prefix}/${cardId}.${ext}`
}

const getPublicPath = (key: string) => {
  if (key.startsWith('uploads/')) {
    return `/u/${key.slice('uploads/'.length)}`
  }

  if (key.startsWith('renders/')) {
    return `/r/${key.slice('renders/'.length)}`
  }

  return `/${key}`
}

const getJsonBody = async (c: { req: { json: () => Promise<unknown> } }) => {
  try {
    return await c.req.json()
  } catch {
    return null
  }
}

const badRequest = (c: { json: (data: unknown, status?: number) => Response }, message: string) =>
  c.json({ error: message }, 400)

app.get('/', (c) => c.text('Hello Hono!'))

app.get('/hello', (c) => {
  const data: ApiResponse = {
    message: 'Hello BHVR!',
    success: true,
  }

  return c.json(data, 200)
})

app.post('/uploads/presign', async (c) => {
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const { cardId, contentType, contentLength, kind } = body as PresignRequest

  if (typeof cardId !== 'string' || cardId.trim() === '') {
    return badRequest(c, 'cardId is required')
  }

  if (typeof contentType !== 'string') {
    return badRequest(c, 'contentType is required')
  }

  if (kind !== 'original' && kind !== 'crop' && kind !== 'render') {
    return badRequest(c, 'kind is invalid')
  }

  const length = typeof contentLength === 'number' ? contentLength : Number(contentLength)

  if (!Number.isFinite(length) || length <= 0) {
    return badRequest(c, 'contentLength must be a positive number')
  }

  if (length > MAX_UPLOAD_BYTES) {
    return badRequest(c, 'File is too large')
  }

  const allowedTypes = kind === 'render' ? ALLOWED_RENDER_TYPES : ALLOWED_UPLOAD_TYPES

  if (!allowedTypes.has(contentType)) {
    return badRequest(c, 'contentType is not allowed')
  }

  const key = getUploadKey(cardId, kind, contentType)

  if (!key) {
    return badRequest(c, 'Unsupported contentType for this upload kind')
  }

  const command = new PutObjectCommand({
    Bucket: Resource.Media.name,
    Key: key,
    ContentType: contentType,
  })

  const uploadUrl = await getSignedUrl(s3, command, { expiresIn: 900 })
  const publicUrl = getPublicPath(key)

  return c.json({
    uploadUrl,
    key,
    publicUrl,
    method: 'PUT',
    headers: { 'Content-Type': contentType },
  })
})

app.post('/cards', async (c) => {
  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const now = nowIso()
  const id = randomUUID()

  const record: CardDesign = {
    id,
    status: 'draft',
    createdAt: now,
    updatedAt: now,
    ...pickCardInput(body),
  }

  await ddb.send(
    new PutCommand({
      TableName: Resource.Cards.name,
      Item: record,
    })
  )

  return c.json(record, 201)
})

app.get('/cards/:id', async (c) => {
  const id = c.req.param('id')

  const result = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!result.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  return c.json(result.Item)
})

app.patch('/cards/:id', async (c) => {
  const id = c.req.param('id')

  const existing = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!existing.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  const body = await getJsonBody(c)
  if (!isRecord(body)) return badRequest(c, 'Invalid request body')

  const updates = pickCardInput(body, { allowStatus: true })
  const now = nowIso()

  const next: CardDesign = {
    ...(existing.Item as CardDesign),
    ...updates,
    id,
    updatedAt: now,
  }

  if (!isCardStatus(next.status)) {
    next.status = (existing.Item as CardDesign).status
  }

  await ddb.send(
    new PutCommand({
      TableName: Resource.Cards.name,
      Item: next,
    })
  )

  return c.json(next)
})

app.post('/cards/:id/submit', async (c) => {
  const id = c.req.param('id')

  const existing = await ddb.send(
    new GetCommand({
      TableName: Resource.Cards.name,
      Key: { id },
    })
  )

  if (!existing.Item) {
    return c.json({ error: 'Card not found' }, 404)
  }

  const body = await getJsonBody(c)
  if (body !== null && !isRecord(body)) return badRequest(c, 'Invalid request body')

  const now = nowIso()
  const next: CardDesign = {
    ...(existing.Item as CardDesign),
    renderKey:
      typeof body?.renderKey === 'string'
        ? body.renderKey
        : (existing.Item as CardDesign).renderKey,
    status: 'submitted',
    updatedAt: now,
  }

  await ddb.send(
    new PutCommand({
      TableName: Resource.Cards.name,
      Item: next,
    })
  )

  return c.json(next)
})

app.notFound((c) => c.json({ error: 'Not Found' }, 404))

app.onError((err, c) => {
  console.error('Server error:', err)
  return c.json({ error: 'Internal Server Error' }, 500)
})

export default app
</file>

<file path="server/src/lambda.ts">
import { handle } from 'hono/aws-lambda'
import app from './index.js'

export const handler = handle(app)
</file>

<file path="server/.gitignore">
# deps
node_modules/
</file>

<file path="server/package.json">
{
  "name": "server",
  "version": "0.0.1",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsx watch src/dev.ts"
  },
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3.955.0",
    "@aws-sdk/client-s3": "^3.955.0",
    "@aws-sdk/lib-dynamodb": "^3.955.0",
    "@aws-sdk/s3-request-presigner": "^3.955.0",
    "@hono/node-server": "^1.13.1",
    "hono": "^4.10.8",
    "shared": "workspace:*",
    "sst": "3.17.25"
  },
  "devDependencies": {
    "@types/node": "^22.19.2",
    "tsx": "^4.20.5"
  }
}
</file>

<file path="server/README.md">
To install dependencies:
```sh
pnpm install
```

To run:
```sh
pnpm run dev
```

open http://localhost:3000
</file>

<file path="server/sst-env.d.ts">
/* This file is auto-generated by SST. Do not edit. */
/* tslint:disable */
/* eslint-disable */
/* deno-fmt-ignore-file */

/// <reference path="../sst-env.d.ts" />

import "sst"
export {}
</file>

<file path="server/tsconfig.json">
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    // Environment settings
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "ESNext",
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx",

    // Types
    "types": ["node"],

    // Output settings
    "declaration": true,
    "outDir": "dist",
    "noEmit": false,
    "emitDecoratorMetadata": true,

    // Module resolution
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": false
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="shared/src/types/index.ts">
export type ApiResponse = {
  message: string;
  success: boolean;
}

export type CardStatus = "draft" | "submitted" | "rendered";

export type CropRect = {
  x: number;
  y: number;
  w: number;
  h: number;
  rotateDeg: 0 | 90 | 180 | 270;
};

export type CardPhoto = {
  originalKey?: string;
  width?: number;
  height?: number;
  crop?: CropRect;
  cropKey?: string;
};

export type CardDesign = {
  id: string;
  templateId?: string;
  type?: string;
  teamId?: string;
  position?: string;
  jerseyNumber?: string;
  firstName?: string;
  lastName?: string;
  photographer?: string;
  photo?: CardPhoto;
  status: CardStatus;
  renderKey?: string;
  createdAt: string;
  updatedAt: string;
};
</file>

<file path="shared/src/index.ts">
export * from "./types"
</file>

<file path="shared/package.json">
{
  "name": "shared",
  "version": "0.0.1",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  },
  "devDependencies": {
    "typescript": "^5.9.3"
  }
}
</file>

<file path="shared/sst-env.d.ts">
/* This file is auto-generated by SST. Do not edit. */
/* tslint:disable */
/* eslint-disable */
/* deno-fmt-ignore-file */

/// <reference path="../sst-env.d.ts" />

import "sst"
export {}
</file>

<file path="shared/tsconfig.json">
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    // Environment setup
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "ESNext",

    // Output configuration
    "declaration": true,
    "outDir": "./dist",
    "noEmit": false,

    // Type checking
    "strict": true,
    "skipLibCheck": true,

    // Additional checks
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "**/*.test.ts", "dist"]
}
</file>

<file path=".gitignore">
# bhvr/.gitignore
# dependencies
node_modules
.pnp
.pnp.js

# testing
coverage

# production
dist
build

# misc
.DS_Store
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
.env*.local

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# editor directories and files
.idea
.vscode/*
!.vscode/extensions.json
!.vscode/settings.json
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Bun
bun.lockb
.turbo

# sst
.sst
</file>

<file path="instructions.md">
We are building an app for creating sports trading cards.
Instructions:

I’m mainly looking for a site that uploads the original photo (cropped to user’s adjustment), any form responses (name, position, number, team, photo cred), and the final image with trading card design to AWS

And for users to adjust the crop with drag and drop instead of the sliders

please read ~/dev/austin-site to see how I use SST for my projects
please read gpt-pro-response.md to see the rough AI plan.
please read ~/dev/tanstack-hono-start/ for a good example of how to use Hono with TanStack and evaluate if we should build off of that.
please read ~/dev/usqc2025/ for last year's trading card app. We will not be reusing anything including design or code, but you can see how it worked. We want to rebuild it better from scratch.
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Steve Simkins

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": ".",
  "version": "0.5.1",
  "description": "A monorepo app built with Hono, Vite, and React",
  "author": "Steve Simkins",
  "license": "MIT",
  "homepage": "https://github.com/stevedylandev/bhvr",
  "packageManager": "pnpm@10.15.0",
  "workspaces": [
    "./server",
    "./client",
    "./shared"
  ],
  "scripts": {
    "build": "turbo build",
    "build:client": "turbo build --filter=client",
    "build:server": "turbo build --filter=server",
    "dev": "turbo dev",
    "dev:client": "turbo dev --filter=client",
    "dev:server": "turbo dev --filter=server",
    "lint": "turbo lint",
    "postinstall": "turbo build --filter=shared --filter=server",
    "test": "turbo test",
    "type-check": "turbo type-check"
  },
  "keywords": ["hono", "react", "vite", "monorepo", "turbo"],
  "devDependencies": {
    "@types/aws-lambda": "8.10.159",
    "turbo": "^2.5.5"
  },
  "peerDependencies": {
    "typescript": "^5.7.3"
  },
  "dependencies": {
    "sst": "3.17.25"
  }
}
</file>

<file path="PLAN.md">
# Trading Card App Plan (Vite + Hono + SST + pnpm)

## Goals
- Provide a public trading-card builder with drag-and-drop crop (no sliders).
- Upload original photo (normalized), crop metadata (and optional cropped derivative), form responses, and final rendered card image.
- Eliminate CORS/black-download issues by serving web + uploads + renders from the same CloudFront domain.
- Keep the stack simple, maintainable, and easy to reskin yearly.

## Current Baseline
- Repo scaffolded from `bun create bhvr@latest` (client/server/shared + Turbo) and converted to pnpm.
- `sst.config.ts` is wired with Router + S3 bucket + Dynamo table + Lambda URL + StaticSite, and Lambda entrypoint is implemented in `server/src/lambda.ts`.
- Server: Hono API with presign + cards CRUD + submit endpoints; uses AWS SDK + `sst` Resource for S3/Dynamo; dev server on port 3000.
- Client: Vite + React with TanStack Router/Query + Tailwind; builder UI with `react-easy-crop`; Vite proxy for `/api`.
- Shared types include `CardDesign`/`CropRect` and related metadata.

## Completed Work (so far)
- Infra wired: Router/Bucket/Dynamo/Function/StaticSite in `sst.config.ts`.
- Lambda handler added via `hono/aws-lambda` (`server/src/lambda.ts`).
- API endpoints implemented: `/api/uploads/presign`, `/api/cards`, `/api/cards/:id` (GET/PATCH), `/api/cards/:id/submit`.
- Client UI scaffolded with form + crop panel + preview and draft save wiring.
- Local dev verified with separate `pnpm -C client dev`, `pnpm -C server dev`, and `sst dev`.

## Next Steps (near-term)
- Wire client to presigned upload flow (original upload + store `originalKey` and dimensions).
- Save crop metadata into the draft on create/update.
- Implement canvas render, presigned upload for renders, and submit flow.
- Add admin list endpoint using the `status` GSI and a lightweight review screen.
- Add validation/error UI; tighten limits; finalize lifecycle + prod CORS origins in `sst.config.ts`.

## Key Decisions & Considerations
- **Frontend:** Vite + React + Tailwind + TanStack Router + TanStack Query.
- **Backend:** Hono on AWS Lambda (via `hono/aws-lambda`).
- **Infra:** SST v3 with a Router and a media bucket; same-origin routing for `/api/*`, `/u/*`, `/r/*`, and the web app.
- **Rendering:** Browser canvas for final image generation (deterministic, no html2canvas).
- **Crop UX:** Drag-and-drop crop with a dedicated crop component (select `react-easy-crop`), persist crop as a normalized rectangle.
- **Storage:** S3 for uploads and renders, DynamoDB for metadata.
- **Security:** Presigned uploads, private buckets with CloudFront OAC access; minimal public exposure.

## Architecture Overview
- **CloudFront (SST Router)**
  - `/` and `/assets/*` → Vite static site bucket
  - `/api/*` → Hono Lambda URL
  - `/u/*` → media bucket `uploads/` prefix
  - `/r/*` → media bucket `renders/` prefix
- **S3**
  - `media` bucket (private, CloudFront access only)
  - `uploads/` and `renders/` prefixes
  - lifecycle for `uploads/` (expire after N days)
  - CORS for direct browser uploads (prod origin + localhost for dev)
- **DynamoDB**
  - table `Cards` for draft/submitted metadata
  - GSI: `status` (PK) + `createdAt` (SK) for admin listing

## Repo Structure (adapted from bhvr)
- `client/` (Vite + React + TanStack Router/Query)
- `server/` (Hono Lambda app)
- `shared/` (types + Zod schemas)
- `sst.config.ts` (infra and routing)
- Add `infra/` if we want to break out stacks later

## Data Model (in `shared/`)
- `CardDesign`
  - `id`, `templateId`, `type`, `teamId`, `position`, `jerseyNumber`, `firstName`, `lastName`, `photographer`
  - `photo`:
    - `originalKey`, `width`, `height`
    - `crop`: `x`, `y`, `w`, `h` (normalized 0..1), `rotateDeg` (0/90/180/270)
    - `cropKey?` (optional cropped derivative)
  - `status`: `draft | submitted | rendered`
  - `renderKey`, `createdAt`, `updatedAt`

## API Surface (Hono)
- `POST /api/uploads/presign`
  - input: `{ cardId, contentType, contentLength, kind: "original" | "crop" | "render" }`
  - validates size + content type (e.g. jpeg/png/webp)
  - output: `{ uploadUrl, key, publicUrl, method, fields? }`
  - note: prefer presigned POST if we need strict size/type enforcement
- `POST /api/cards`
  - create draft
- `GET /api/cards/:id`
  - fetch draft
- `PATCH /api/cards/:id`
  - update draft + crop metadata
- `POST /api/cards/:id/submit`
  - mark submitted; include `renderKey`

## Upload & Render Flow
1. Client requests presign for original upload (`kind=original`).
2. Client uploads to S3 directly, stores `originalKey` in draft.
3. Client stores crop metadata (and optionally uploads a cropped derivative with `kind=crop`).
4. Client renders final card to canvas and uploads via presign (`kind=render`).
5. Client calls `submit` with `renderKey` + form data.

## S3 Object Key Scheme
- `uploads/original/<cardId>.<ext>`
- `uploads/crop/<cardId>.jpg` (optional)
- `renders/<cardId>.png`

## Crop UX & Rendering
- Use `react-easy-crop` with drag/pinch/scroll for crop and zoom.
- Persist crop rectangle in normalized image coordinates (0..1) plus rotation.
- Canvas renderer uses a consistent template geometry (825x1125).
- Handle EXIF orientation in-browser prior to rendering.

## Infra Plan (SST)
- Create `media` bucket with `access: "cloudfront"`.
- Create `cards` Dynamo table with `id` hash key and GSI on `status` + `createdAt`.
- Create Hono Lambda with `url: true`, link bucket + table, Lambda entrypoint uses `hono/aws-lambda`.
- Create Router:
  - `router.route("/api", api.url, { rewrite: { regex: "^/api/(.*)$", to: "/$1" } })`
  - `router.routeBucket("/u", bucket, { rewrite: { regex: "^/u/(.*)$", to: "/uploads/$1" } })`
  - `router.routeBucket("/r", bucket, { rewrite: { regex: "^/r/(.*)$", to: "/renders/$1" } })`
- Serve `client/` via `sst.aws.StaticSite` with `router: { instance: router }`.
- Bucket policy and CORS:
  - Allow CloudFront OAC `s3:GetObject` for media bucket.
  - Allow Lambda role to sign presigned uploads; scope `s3:PutObject` to `uploads/*` and `renders/*`.
  - CORS allow `PUT/POST/HEAD` from prod origin and localhost.

## Local Dev Workflow
- `pnpm install`
- `pnpm dev` for client/server shared builds
- Vite proxy `/api` to the local Hono server; client calls relative `/api`.
- `sst dev` for infra + live Lambda (optional). For local dev, use the proxy to avoid CORS and run Vite separately.
- Provide `.env` files for local endpoints and AWS profiles.

## Risks & Mitigations
- **Node runtime alignment:** keep Lambda entrypoint Node-compatible and avoid runtime-specific APIs.
- **SST + Router config drift:** keep route patterns and Vite `base` aligned.
- **Large images and memory:** constrain file size at presign and downscale in browser if needed.
- **Presigned uploads + OAC:** ensure bucket policy allows presigned writes while keeping reads behind CloudFront.

## Completed Cleanup Items
- Import shared types from `shared` (not `shared/dist`) to keep runtime/bundler behavior consistent.
- Fix placeholder types in `shared` (e.g. `success` should be `boolean`).
- Remove Bun-only types from the server build path and use Node types.

## Milestones
1. **Phase 0: Infra Skeleton (done)**
   - Lambda entrypoint (`hono/aws-lambda`)
   - Vite `/api` proxy and client routing
   - TanStack Router + Query wiring
2. **Phase 1: Card Builder UI (in progress)**
   - Form + crop UI + preview shell in place
3. **Phase 2: AWS Uploads (API done, client pending)**
   - Presigned upload API exists; client integration next
4. **Phase 3: Submission Pipeline**
   - Canvas render, upload final image, submit and persist
5. **Phase 4: Hardening**
   - Error handling, validation, logging, lifecycle rules

## Open Questions
- Which domain/subdomain should the Router use?
- Retention period for `uploads/` and `renders/`?
- Presigned upload method: PUT vs POST?
- Store cropped derivative, or only original + crop metadata?
- Any admin interface required in v1?
</file>

<file path="pnpm-workspace.yaml">
packages:
  - client
  - server
  - shared

onlyBuiltDependencies:
  - aws-sdk
  - esbuild
</file>

<file path="README.md">
# Trading Card App

A monorepo app for building and submitting sports trading cards.

## Setup

```sh
pnpm install
```

## Development

```sh
pnpm dev
```

- `client/` is the Vite + React app
- `server/` is the Hono API (Lambda-compatible)
- `shared/` holds shared types/schemas

## SST

```sh
sst dev
```

Use `sst deploy` when you're ready to deploy.
</file>

<file path="sst-env.d.ts">
/* This file is auto-generated by SST. Do not edit. */
/* tslint:disable */
/* eslint-disable */
/* deno-fmt-ignore-file */

declare module "sst" {
  export interface Resource {
    "Api": {
      "name": string
      "type": "sst.aws.Function"
      "url": string
    }
    "CardRouter": {
      "type": "sst.aws.Router"
      "url": string
    }
    "Cards": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "Media": {
      "name": string
      "type": "sst.aws.Bucket"
    }
    "Web": {
      "type": "sst.aws.StaticSite"
      "url": string
    }
  }
}
/// <reference path="sst-env.d.ts" />

import "sst"
export {}
</file>

<file path="sst.config.ts">
/// <reference path="./.sst/platform/config.d.ts" />

export default $config({
  app(input) {
    return {
      name: "trading-card-app",
      removal: input?.stage === "production" ? "retain" : "remove",
      protect: ["production"].includes(input?.stage),
      home: "aws",
    };
  },
  async run() {
    const router = new sst.aws.Router("CardRouter");

    const mediaBucket = new sst.aws.Bucket("Media", {
      access: "cloudfront",
      cors: {
        allowHeaders: ["*"],
        allowMethods: ["GET", "HEAD", "POST", "PUT"],
        allowOrigins: ["http://localhost:5173", "http://localhost:3000"],
      },
    });

    const cardsTable = new sst.aws.Dynamo("Cards", {
      fields: {
        id: "string",
        status: "string",
        createdAt: "string",
      },
      primaryIndex: { hashKey: "id" },
      globalIndexes: {
        byStatus: { hashKey: "status", rangeKey: "createdAt" },
      },
    });

    const api = new sst.aws.Function("Api", {
      handler: "server/src/lambda.handler",
      runtime: "nodejs20.x",
      url: true,
      link: [mediaBucket, cardsTable],
    });

    router.route("/api", api.url, {
      rewrite: { regex: "^/api/(.*)$", to: "/$1" },
    });
    router.routeBucket("/u", mediaBucket, {
      rewrite: { regex: "^/u/(.*)$", to: "/uploads/$1" },
    });
    router.routeBucket("/r", mediaBucket, {
      rewrite: { regex: "^/r/(.*)$", to: "/renders/$1" },
    });

    const web = new sst.aws.StaticSite("Web", {
      path: "client",
      build: {
        command: "pnpm build",
        output: "dist",
      },
      router: { instance: router },
    });

    return {
      web: web.url,
      api: api.url,
      router: router.url,
      media: mediaBucket.name,
      cards: cardsTable.name,
    };
  },
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    // Environment setup & latest features
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Path resolution
    "baseUrl": "./",
    "paths": {
      "@server/*": ["./server/src/*"],
      "@client/*": ["./client/src/*"],
      "@shared/*": ["./shared/src/*"]
    },

    // Module resolution
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "verbatimModuleSyntax": true,

    // Strictness and best practices
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "experimentalDecorators": true,

    // Output control
    "skipLibCheck": true,

    // Optional strict flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
</file>

<file path="turbo.json">
{
  "$schema": "https://turbo.build/schema.json",
  "ui": "tui",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": [
        "src/**/*.ts",
        "src/**/*.tsx",
        "src/**/*.js",
        "src/**/*.jsx",
        "src/**/*.json",
        "tsconfig.json",
        "tsconfig.*.json",
        "vite.config.ts",
        "package.json",
        "pnpm-lock.yaml",
        "eslint.config.js",
        "index.html"
      ],
      "outputs": ["dist/**", "build/**", ".turbo/**"],
      "env": ["NODE_ENV", "VITE_*"]
    },
    "dev": {
      "cache": false,
      "persistent": true,
      "inputs": [
        "src/**/*.ts",
        "src/**/*.tsx",
        "src/**/*.js",
        "src/**/*.jsx",
        "tsconfig.json",
        "tsconfig.*.json",
        "vite.config.ts",
        "package.json"
      ],
      "env": ["NODE_ENV", "PORT", "VITE_*"]
    },
    "lint": {
      "dependsOn": ["^build"],
      "inputs": [
        "src/**/*.ts",
        "src/**/*.tsx",
        "src/**/*.js",
        "src/**/*.jsx",
        "eslint.config.js",
        ".eslintrc*",
        "package.json",
        "tsconfig.json",
        "tsconfig.*.json"
      ],
      "outputs": [".eslintcache"],
      "env": ["NODE_ENV"]
    },
    "type-check": {
      "dependsOn": ["^build"],
      "inputs": [
        "src/**/*.ts",
        "src/**/*.tsx",
        "src/**/*.d.ts",
        "tsconfig.json",
        "tsconfig.*.json",
        "package.json"
      ],
      "outputs": ["dist/**/*.d.ts", ".tsbuildinfo"],
      "env": ["NODE_ENV"]
    },
    "test": {
      "dependsOn": ["^build"],
      "inputs": [
        "src/**/*.ts",
        "src/**/*.tsx",
        "src/**/*.js",
        "src/**/*.jsx",
        "test/**/*.ts",
        "test/**/*.tsx",
        "test/**/*.js",
        "test/**/*.jsx",
        "__tests__/**/*.ts",
        "__tests__/**/*.tsx",
        "**/*.test.ts",
        "**/*.test.tsx",
        "**/*.spec.ts",
        "**/*.spec.tsx",
        "jest.config.*",
        "vitest.config.*",
        "package.json",
        "tsconfig.json",
        "tsconfig.*.json"
      ],
      "outputs": ["coverage/**", ".nyc_output/**", "test-results/**"],
      "env": ["NODE_ENV", "CI"]
    }
  },
  "globalDependencies": [
    "**/.env",
    "**/.env.*",
    "**/.env.local",
    "**/.env.*.local",
    ".gitignore",
    "turbo.json",
    "package.json",
    "pnpm-workspace.yaml",
    "pnpm-lock.yaml",
    "tsconfig.json"
  ],
  "globalEnv": ["NODE_ENV", "CI", "TURBO_TOKEN", "TURBO_TEAM", "TURBO_REMOTE_ONLY"]
}
</file>

</files>
